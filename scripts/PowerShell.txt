PowerShell 7.6.0-preview.4
PS C:\Users\kushal> C:\code\TSP\scripts\cat.ps1
On branch master
Your branch is ahead of 'origin/master' by 10 commits.
  (use "git push" to publish your local commits)

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   scripts/PowerShell.txt

no changes added to commit (use "git add" and/or "git commit -a")
* remote origin
  Fetch URL: git@github.com:kusl/tsp.git
  Push  URL: git@github.com:kusl/tsp.git
  HEAD branch: master
  Remote branch:
    master tracked
  Local branch configured for 'git pull':
    master merges with remote master
  Local ref configured for 'git push':
    master pushes to master (fast-forwardable)
Removing TravelingSalesman.ConsoleApp/obj/
Removing TravelingSalesman.Core/bin/
Removing TravelingSalesman.Core/obj/
Removing TravelingSalesman.Tests/bin/
Removing TravelingSalesman.Tests/obj/
Folder PATH listing
Volume serial number is BE05-6605
C:.
│   .dockerignore
│   .gitattributes
│   .gitignore
│   Directory.Build.props
│   Directory.Packages.props
│   Dockerfile
│   LICENSE.txt
│   README.md
│   TSP.sln
│
├───.github
│   └───workflows
│           build.yml
│           release.yml
│
├───scripts
│       cat.ps1
│       PowerShell.txt
│
├───TravelingSalesman.ConsoleApp
│   │   Program.cs
│   │   TravelingSalesman.ConsoleApp.csproj
│   │
│   └───Properties
│           launchSettings.json
│
├───TravelingSalesman.Core
│       TravelingSalesman.Core.csproj
│       TravelingSalesmanLibrary.cs
│
└───TravelingSalesman.Tests
        Tests.cs
        TravelingSalesman.Tests.csproj


=== SLN FILE ===

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.14.36408.4
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TravelingSalesman.Core", "TravelingSalesman.Core\TravelingSalesman.Core.csproj", "{C2346882-82C9-4200-AD54-AB85B62D0297}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TravelingSalesman.ConsoleApp", "TravelingSalesman.ConsoleApp\TravelingSalesman.ConsoleApp.csproj", "{304BB409-E7A3-484A-9EB2-2864B7868DD2}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{8EC462FD-D22E-90A8-E5CE-7E832BA40C5D}"
        ProjectSection(SolutionItems) = preProject
                .github\workflows\build.yml = .github\workflows\build.yml
                Dockerfile = Dockerfile
        EndProjectSection
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "TravelingSalesman.Tests", "TravelingSalesman.Tests\TravelingSalesman.Tests.csproj", "{0515DBB2-D0F7-4F5C-B91F-B4E0262E2C7B}"
EndProject
Global
        GlobalSection(SolutionConfigurationPlatforms) = preSolution
                Debug|Any CPU = Debug|Any CPU
                Release|Any CPU = Release|Any CPU
        EndGlobalSection
        GlobalSection(ProjectConfigurationPlatforms) = postSolution
                {C2346882-82C9-4200-AD54-AB85B62D0297}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
                {C2346882-82C9-4200-AD54-AB85B62D0297}.Debug|Any CPU.Build.0 = Debug|Any CPU
                {C2346882-82C9-4200-AD54-AB85B62D0297}.Release|Any CPU.ActiveCfg = Release|Any CPU
                {C2346882-82C9-4200-AD54-AB85B62D0297}.Release|Any CPU.Build.0 = Release|Any CPU
                {304BB409-E7A3-484A-9EB2-2864B7868DD2}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
                {304BB409-E7A3-484A-9EB2-2864B7868DD2}.Debug|Any CPU.Build.0 = Debug|Any CPU
                {304BB409-E7A3-484A-9EB2-2864B7868DD2}.Release|Any CPU.ActiveCfg = Release|Any CPU
                {304BB409-E7A3-484A-9EB2-2864B7868DD2}.Release|Any CPU.Build.0 = Release|Any CPU
                {0515DBB2-D0F7-4F5C-B91F-B4E0262E2C7B}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
                {0515DBB2-D0F7-4F5C-B91F-B4E0262E2C7B}.Debug|Any CPU.Build.0 = Debug|Any CPU
                {0515DBB2-D0F7-4F5C-B91F-B4E0262E2C7B}.Release|Any CPU.ActiveCfg = Release|Any CPU
                {0515DBB2-D0F7-4F5C-B91F-B4E0262E2C7B}.Release|Any CPU.Build.0 = Release|Any CPU
        EndGlobalSection
        GlobalSection(SolutionProperties) = preSolution
                HideSolutionNode = FALSE
        EndGlobalSection
        GlobalSection(ExtensibilityGlobals) = postSolution
                SolutionGuid = {A273C62C-9A31-4047-9AAB-4C20C12D1666}
        EndGlobalSection
EndGlobal

=== DOCKERFILE ===
# See https://aka.ms/customizecontainer to learn how to customize your debug container and how Visual Studio uses this Dockerfile to build your images for faster debugging.

# Version configuration - change these two lines when upgrading .NET versions
ARG DOTNET_VERSION=9.0
ARG DOTNET_VERSION_EXACT=9.0

# These ARGs allow for swapping out the base used to make the final image when debugging from VS
ARG LAUNCHING_FROM_VS
# This sets the base image for final, but only if LAUNCHING_FROM_VS has been defined
ARG FINAL_BASE_IMAGE=${LAUNCHING_FROM_VS:+aotdebug}

# This stage is used when running from VS in fast mode (Default for Debug configuration)
FROM mcr.microsoft.com/dotnet/runtime:${DOTNET_VERSION} AS base
USER $APP_UID
WORKDIR /app

# This stage is used to build the service project
FROM mcr.microsoft.com/dotnet/sdk:${DOTNET_VERSION} AS build
# Install clang/zlib1g-dev dependencies for publishing to native
RUN apt-get update \
    && apt-get install -y --no-install-recommends \
    clang zlib1g-dev
ARG BUILD_CONFIGURATION=Release
WORKDIR /src

# Copy solution and MSBuild configuration files FIRST
COPY ["TSP.sln", "./"]
COPY ["Directory.Build.props", "./"]
COPY ["Directory.Packages.props", "./"]

# Copy project files for both projects
COPY ["TravelingSalesman.ConsoleApp/TravelingSalesman.ConsoleApp.csproj", "TravelingSalesman.ConsoleApp/"]
COPY ["TravelingSalesman.Core/TravelingSalesman.Core.csproj", "TravelingSalesman.Core/"]

# Restore the console app (which will also restore its dependencies)
RUN dotnet restore "TravelingSalesman.ConsoleApp/TravelingSalesman.ConsoleApp.csproj"

# Copy all source code
COPY . .

WORKDIR "/src/TravelingSalesman.ConsoleApp"
RUN dotnet build "TravelingSalesman.ConsoleApp.csproj" -c $BUILD_CONFIGURATION -o /app/build

# This stage is used to publish the service project to be copied to the final stage
FROM build AS publish
ARG BUILD_CONFIGURATION=Release
RUN dotnet publish "TravelingSalesman.ConsoleApp.csproj" -c $BUILD_CONFIGURATION -o /app/publish /p:UseAppHost=true

# This stage is used as the base for the final stage when launching from VS to support debugging in regular mode (Default when not using the Debug configuration)
FROM base AS aotdebug
USER root
# Install GDB to support native debugging
RUN apt-get update \
    && apt-get install -y --no-install-recommends \
    gdb
USER app

# This stage is used in production or when running from VS in regular mode (Default when not using the Debug configuration)
# Re-declare the ARG in this stage so it's available
ARG DOTNET_VERSION=9.0
FROM ${FINAL_BASE_IMAGE:-mcr.microsoft.com/dotnet/runtime-deps:${DOTNET_VERSION}} AS final
WORKDIR /app

# Create logs directory for Serilog file output
RUN mkdir -p /app/logs && \
    chmod 755 /app/logs

COPY --from=publish /app/publish .
ENTRYPOINT ["./TravelingSalesman.ConsoleApp"]

=== Properties FILE ===
<Project>
  <PropertyGroup>
    <!-- Version Management - these will be updated by CI/CD -->
    <!-- Use a more CI-friendly format to avoid sed issues -->
    <Version Condition="'$(Version)' == ''">1.2.0</Version>
    <AssemblyVersion Condition="'$(AssemblyVersion)' == ''">1.2.0.0</AssemblyVersion>
    <FileVersion Condition="'$(FileVersion)' == ''">1.2.0.0</FileVersion>
    <InformationalVersion Condition="'$(InformationalVersion)' == ''">1.2.0</InformationalVersion>

    <!-- Centralized .NET version management -->
    <TargetFramework>net9.0</TargetFramework>
    <DotNetVersion>9.0</DotNetVersion>
    <DotNetChannel>9.0</DotNetChannel>

    <!-- When .NET 10 releases, just update these three lines -->
    <!-- <TargetFramework>net10.0</TargetFramework> -->
    <!-- <DotNetVersion>10.0</DotNetVersion> -->
    <!-- <DotNetChannel>10.0</DotNetChannel> -->

    <!-- Shared project settings -->
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
    <AnalysisLevel>latest</AnalysisLevel>

    <!-- AOT settings for console apps -->
    <PublishAot Condition="'$(OutputType)' == 'Exe'">true</PublishAot>
    <InvariantGlobalization Condition="'$(PublishAot)' == 'true'">true</InvariantGlobalization>

    <!-- Optimize for size and startup time -->
    <PublishSingleFile Condition="'$(PublishAot)' == 'true'">true</PublishSingleFile>
    <PublishTrimmed Condition="'$(PublishAot)' == 'true'">true</PublishTrimmed>
    <TrimMode Condition="'$(PublishAot)' == 'true'">link</TrimMode>

    <!-- Company/Product Info -->
    <Company>TSP Solutions</Company>
    <Product>Traveling Salesman Problem Solver</Product>
    <Copyright>Copyright © 2025 TSP Solutions</Copyright>
    <Description>Advanced TSP solver with multiple algorithms</Description>

    <!-- Assembly metadata for better debugging -->
    <AssemblyTitle>$(Product)</AssemblyTitle>
    <AssemblyDescription>$(Description)</AssemblyDescription>
    <AssemblyCompany>$(Company)</AssemblyCompany>
    <AssemblyProduct>$(Product)</AssemblyProduct>
    <AssemblyCopyright>$(Copyright)</AssemblyCopyright>
  </PropertyGroup>

  <!-- Conditional compilation symbols for different builds -->
  <PropertyGroup Condition="'$(Configuration)' == 'Debug'">
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <DebugType>portable</DebugType>
    <DebugSymbols>true</DebugSymbols>
  </PropertyGroup>

  <PropertyGroup Condition="'$(Configuration)' == 'Release'">
    <DefineConstants>TRACE</DefineConstants>
    <DebugType>none</DebugType>
    <DebugSymbols>false</DebugSymbols>
    <Optimize>true</Optimize>
  </PropertyGroup>

  <!-- Package settings for libraries -->
  <PropertyGroup Condition="'$(IsPackable)' == 'true'">
    <GeneratePackageOnBuild>false</GeneratePackageOnBuild>
    <PackageId>$(AssemblyName)</PackageId>
    <PackageVersion>$(Version)</PackageVersion>
    <Authors>$(Company)</Authors>
    <PackageDescription>$(Description)</PackageDescription>
    <PackageLicenseExpression>MIT</PackageLicenseExpression>
    <PackageProjectUrl>https://github.com/kusl/tsp</PackageProjectUrl>
    <RepositoryUrl>https://github.com/kusl/tsp.git</RepositoryUrl>
    <RepositoryType>git</RepositoryType>
    <PackageTags>tsp;traveling-salesman;optimization;algorithms</PackageTags>
  </PropertyGroup>
</Project>
<Project>
  <!-- Enable Central Package Management -->
  <PropertyGroup>
    <ManagePackageVersionsCentrally>true</ManagePackageVersionsCentrally>
  </PropertyGroup>
  <!-- Central Package Version Management -->
  <ItemGroup>
    <!-- Logging -->
    <PackageVersion Include="Microsoft.Extensions.Logging.Abstractions" Version="9.0.8" />
    <PackageVersion Include="Microsoft.Extensions.Logging" Version="9.0.8" />
    <PackageVersion Include="Serilog" Version="4.3.0" />
    <PackageVersion Include="Serilog.Extensions.Logging" Version="9.0.2" />
    <PackageVersion Include="Serilog.Sinks.Console" Version="6.0.0" />
    <PackageVersion Include="Serilog.Sinks.File" Version="7.0.0" />
    <PackageVersion Include="Serilog.Formatting.Compact" Version="3.0.0" />
    <PackageVersion Include="coverlet.collector" Version="6.0.4" />
    <PackageVersion Include="Microsoft.NET.Test.Sdk" Version="17.14.1" />
    <PackageVersion Include="xunit" Version="2.9.3" />
    <PackageVersion Include="xunit.runner.visualstudio" Version="3.1.4" />
  </ItemGroup>
</Project>

=== GITHUB ACTIONS ===
name: Build and Test TSP Solver

on:
  push:
    branches: [ master, main ]
  pull_request:
    branches: [ master, main ]
  workflow_dispatch:

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build Docker image
      run: |
        docker build -t tsp-solver:latest .
        echo "✅ Docker image built successfully"
        docker images | grep tsp-solver

    - name: Test - Benchmark with 10 cities
      run: |
        echo "Running benchmark test with 10 cities..."
        echo -e "2\n10\n5\n" | timeout 30s docker run --rm -i tsp-solver:latest | tee benchmark_output.log || true

        if grep -q "Benchmark completed" benchmark_output.log; then
          echo "✅ Benchmark completed successfully"
          grep -A 5 "Winner:" benchmark_output.log || true
        else
          echo "⚠️ Benchmark may not have completed properly"
        fi

    - name: Test - Interactive solver with Nearest Neighbor
      run: |
        echo "Testing Nearest Neighbor algorithm with 8 cities..."
        echo -e "1\n8\n1\n1\nn\n5\n" | timeout 20s docker run --rm -i tsp-solver:latest | tee nn_output.log || true

        if grep -q "Solution Found" nn_output.log; then
          echo "✅ Nearest Neighbor test completed"
          grep "Total Distance:" nn_output.log || true
        else
          echo "⚠️ Nearest Neighbor test may not have completed"
        fi

    - name: Test - Demonstration mode
      run: |
        echo "Running demonstration mode..."
        echo -e "3\n5\n" | timeout 60s docker run --rm -i tsp-solver:latest | tee demo_output.log || true

        if grep -q "Demonstration Complete" demo_output.log; then
          echo "✅ Demonstration completed successfully"
        else
          echo "⚠️ Demonstration may not have completed"
        fi

    - name: Test - Algorithm Information
      run: |
        echo "Getting algorithm information..."
        echo -e "4\n5\n" | timeout 10s docker run --rm -i tsp-solver:latest | tee info_output.log || true

        if grep -q "Algorithm Information" info_output.log; then
          echo "✅ Algorithm info displayed successfully"
        else
          echo "⚠️ Algorithm info test may not have completed"
        fi

    - name: Test - Log File Creation
      run: |
        echo "Testing log file creation..."
        # Run a quick test and check if logs directory is created
        echo -e "4\n5\n" | timeout 10s docker run --rm -v $(pwd)/test-logs:/app/logs tsp-solver:latest | tee log_test.log || true

        if [ -d "test-logs" ] && [ "$(ls -A test-logs)" ]; then
          echo "✅ Log files created successfully"
          ls -la test-logs/ || true
          echo "Sample log content:"
          head -5 test-logs/* 2>/dev/null || true
        else
          echo "⚠️ Log files may not have been created"
        fi

    - name: Upload test results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: test-outputs
        path: |
          *_output.log
          log_test.log
          test-logs/

    - name: Display summary
      if: always()
      run: |
        echo "## Test Summary"
        echo "Docker image size:"
        docker images tsp-solver:latest --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"

        echo ""
        echo "Test files generated:"
        ls -lh *_output.log log_test.log 2>/dev/null || echo "No output files found"

        echo ""
        echo "Log directory test:"
        if [ -d "test-logs" ]; then
          echo "✅ Logs directory created"
          du -sh test-logs/ 2>/dev/null || true
        else
          echo "❌ Logs directory not found"
        fi

  build-native-dotnet:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '9.0.x'

    - name: Restore dependencies
      run: dotnet restore TSP.sln

    - name: Build
      run: dotnet build TSP.sln --configuration Release --no-restore

    - name: Run Tests
      run: dotnet test TSP.sln --configuration Release --no-build --verbosity normal

    - name: Test Coverage
      run: |
        dotnet test TSP.sln --configuration Release --no-build \
          --collect:"XPlat Code Coverage" \
          --results-directory ./coverage

    - name: Test Version Information
      run: |
        echo "Testing assembly version information..."
        cd TravelingSalesman.ConsoleApp/bin/Release/net9.0

        # Check if version is properly embedded
        if command -v strings >/dev/null 2>&1; then
          echo "Assembly version info:"
          strings TravelingSalesman.ConsoleApp.dll | grep -E "^[0-9]+\.[0-9]+\.[0-9]+" || echo "Version strings not found"
        fi

    - name: Run without Docker
      run: |
        echo "Testing native .NET build with logging..."
        cd TravelingSalesman.ConsoleApp/bin/Release/net9.0

        # Test basic functionality and log creation
        echo -e "4\n5\n" | timeout 10s dotnet TravelingSalesman.ConsoleApp.dll || true

        # Check if logs directory was created
        if [ -d "logs" ]; then
          echo "✅ Logs directory created in native build"
          ls -la logs/ || true
        else
          echo "❌ Logs directory not created in native build"
        fi

    - name: Publish AOT (if supported)
      continue-on-error: true
      run: |
        echo "Publishing AOT build..."
        dotnet publish TravelingSalesman.ConsoleApp/TravelingSalesman.ConsoleApp.csproj \
          -c Release \
          -r linux-x64 \
          --self-contained true \
          -p:PublishAot=true \
          -o ./publish-aot

        echo "AOT published files:"
        ls -lh ./publish-aot/ || true

        # Test AOT binary
        if [ -f "./publish-aot/TravelingSalesman.ConsoleApp" ]; then
          echo "Testing AOT binary..."
          echo -e "4\n5\n" | timeout 10s ./publish-aot/TravelingSalesman.ConsoleApp || true

          # Check logs for AOT build
          if [ -d "./publish-aot/logs" ]; then
            echo "✅ AOT build creates logs successfully"
          else
            echo "⚠️ AOT build may not create logs directory"
          fi
        fi

    - name: Upload native build artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: native-build-logs
        path: |
          TravelingSalesman.ConsoleApp/bin/Release/net9.0/logs/
          publish-aot/logs/
name: Continuous Release

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]
  workflow_dispatch:

env:
  DOTNET_VERSION: '9.0.x'
  DOTNET_CLI_TELEMETRY_OPTOUT: 1
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1

jobs:
  build-and-release:
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: windows-latest
            rid: win-x64
            binary_extension: .exe
          - os: ubuntu-latest
            rid: linux-x64
            binary_extension: ""
          - os: macos-latest
            rid: osx-x64
            binary_extension: ""
          - os: macos-latest
            rid: osx-arm64
            binary_extension: ""

    runs-on: ${{ matrix.os }}

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Generate version info
      id: version
      shell: bash
      run: |
        # Generate a more stable version format
        YEAR_SHORT=$(($(date +'%Y') - 2000))
        MONTH=$((10#$(date +'%m')))
        DAY=$((10#$(date +'%d')))

        # Get build number from commits, but keep it reasonable
        RAW_BUILD=$(git rev-list --count HEAD)
        BUILD_NUMBER=$((RAW_BUILD % 10000 + 1000))  # Keep between 1000-10999

        SHORT_SHA=$(git rev-parse --short=8 HEAD)

        # Create semantic version (max 4 parts for .NET)
        VERSION="${YEAR_SHORT}.${MONTH}.${DAY}.${BUILD_NUMBER}"
        FULL_VERSION="${VERSION}-${SHORT_SHA}"

        echo "version=${VERSION}" >> $GITHUB_OUTPUT
        echo "full_version=${FULL_VERSION}" >> $GITHUB_OUTPUT
        echo "sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
        echo "build_number=${BUILD_NUMBER}" >> $GITHUB_OUTPUT

        echo "Generated versions:"
        echo "  Assembly version: ${VERSION}"
        echo "  Full version: ${FULL_VERSION}"
        echo "  Commit: ${SHORT_SHA}"

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}

    - name: Update version in Directory.Build.props
      shell: bash
      run: |
        echo "Updating version information..."

        # Create a new Directory.Build.props with updated versions
        cat > Directory.Build.props.new << 'EOF'
        <Project>
          <PropertyGroup>
            <Version>${{ steps.version.outputs.version }}</Version>
            <AssemblyVersion>${{ steps.version.outputs.version }}</AssemblyVersion>
            <FileVersion>${{ steps.version.outputs.version }}</FileVersion>
            <InformationalVersion>${{ steps.version.outputs.full_version }}</InformationalVersion>
        EOF

        # Append the rest of the original file (skip the first few version lines)
        tail -n +8 Directory.Build.props >> Directory.Build.props.new
        mv Directory.Build.props.new Directory.Build.props

        echo "Updated Directory.Build.props:"
        head -10 Directory.Build.props

    - name: Restore dependencies
      run: dotnet restore TSP.sln

    - name: Build native binary
      shell: bash
      run: |
        echo "Building for ${{ matrix.rid }}..."

        # Ensure output directory exists
        mkdir -p artifacts

        dotnet publish TravelingSalesman.ConsoleApp/TravelingSalesman.ConsoleApp.csproj \
          -c Release \
          -r ${{ matrix.rid }} \
          --self-contained \
          -p:PublishAot=true \
          -p:PublishSingleFile=true \
          -p:PublishTrimmed=true \
          -o ./publish-${{ matrix.rid }} \
          --verbosity minimal

        echo "Build completed. Files in publish directory:"
        ls -la ./publish-${{ matrix.rid }}/

        # Create final binary name
        BINARY_NAME="TSP-${{ matrix.rid }}-${{ steps.version.outputs.sha }}${{ matrix.binary_extension }}"

        # Move and rename the binary
        if [[ "${{ matrix.rid }}" == win-* ]]; then
          mv "./publish-${{ matrix.rid }}/TravelingSalesman.ConsoleApp.exe" "./artifacts/${BINARY_NAME}"
        else
          mv "./publish-${{ matrix.rid }}/TravelingSalesman.ConsoleApp" "./artifacts/${BINARY_NAME}"
          chmod +x "./artifacts/${BINARY_NAME}"
        fi

        echo "Binary created: ${BINARY_NAME}"
        ls -lah ./artifacts/

    - name: Test binary functionality
      shell: bash
      continue-on-error: true
      run: |
        echo "Testing binary functionality..."
        cd artifacts

        BINARY_NAME="TSP-${{ matrix.rid }}-${{ steps.version.outputs.sha }}${{ matrix.binary_extension }}"

        if [ ! -f "$BINARY_NAME" ]; then
          echo "❌ Binary not found: $BINARY_NAME"
          ls -la
          exit 1
        fi

        echo "✅ Binary exists: $BINARY_NAME ($(du -h "$BINARY_NAME" | cut -f1))"

        # Test execution with timeout and error handling
        echo "Testing binary execution..."
        if timeout 30s sh -c "echo -e '4\n5\n' | ./'$BINARY_NAME'" > test_output.log 2>&1; then
          echo "✅ Binary executed successfully"

          # Check for log directory creation
          if [ -d "logs" ]; then
            echo "✅ Logs directory created"
            if [ "$(ls -A logs 2>/dev/null)" ]; then
              echo "✅ Log files created:"
              ls -la logs/
              echo "Sample log content (first 3 lines):"
              head -3 logs/* 2>/dev/null | head -10 || echo "No readable log content"
            else
              echo "⚠️ Logs directory empty"
            fi
          else
            echo "⚠️ Logs directory not created"
          fi

          # Show some output
          echo "Test output (first 20 lines):"
          head -20 test_output.log || echo "No output captured"
        else
          echo "⚠️ Binary test failed or timed out"
          echo "Test output:"
          cat test_output.log 2>/dev/null || echo "No output captured"
        fi

    - name: Upload build artifact
      uses: actions/upload-artifact@v4
      with:
        name: binary-${{ matrix.rid }}
        path: |
          ./artifacts/TSP-${{ matrix.rid }}-${{ steps.version.outputs.sha }}${{ matrix.binary_extension }}
          ./artifacts/logs/
          ./artifacts/test_output.log
        if-no-files-found: warn

  create-release:
    if: github.event_name == 'push' && github.ref == 'refs/heads/master'
    needs: build-and-release
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Generate version info
      id: version
      shell: bash
      run: |
        # Use same logic as build job
        YEAR_SHORT=$(($(date +'%Y') - 2000))
        MONTH=$((10#$(date +'%m')))
        DAY=$((10#$(date +'%d')))
        RAW_BUILD=$(git rev-list --count HEAD)
        BUILD_NUMBER=$((RAW_BUILD % 10000 + 1000))
        SHORT_SHA=$(git rev-parse --short=8 HEAD)

        VERSION="${YEAR_SHORT}.${MONTH}.${DAY}.${BUILD_NUMBER}"
        FULL_VERSION="${VERSION}-${SHORT_SHA}"

        echo "version=${VERSION}" >> $GITHUB_OUTPUT
        echo "full_version=${FULL_VERSION}" >> $GITHUB_OUTPUT
        echo "sha=${SHORT_SHA}" >> $GITHUB_OUTPUT

    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        path: ./artifacts

    - name: Debug artifact structure
      run: |
        echo "Downloaded artifacts structure:"
        find ./artifacts -type f -ls | head -30
        echo ""
        echo "Looking for binaries:"
        find ./artifacts -name "TSP-*" -type f -ls

    - name: Prepare release assets
      run: |
        mkdir -p ./release-assets

        # Copy all binaries
        echo "Copying binaries..."
        find ./artifacts -name "TSP-*" -type f \( -name "*.exe" -o ! -name "*.*" \) -exec cp -v {} ./release-assets/ \;

        # Copy any log files that exist
        echo "Copying log files..."
        find ./artifacts -name "*.log" -type f -exec cp -v {} ./release-assets/ \; 2>/dev/null || echo "No log files found"

        # Create comprehensive version info
        cat > ./release-assets/version.txt << EOF
        TSP Solver Release Information
        ============================
        Version: ${{ steps.version.outputs.full_version }}
        Assembly Version: ${{ steps.version.outputs.version }}
        Commit: ${{ github.sha }}
        Short SHA: ${{ steps.version.outputs.sha }}
        Branch: ${{ github.ref_name }}
        Build Date: $(date -u +'%Y-%m-%d %H:%M:%S UTC')
        Build Trigger: ${{ github.event_name }}

        Supported Platforms:
        - Windows x64 (Native AOT)
        - Linux x64 (Native AOT)
        - macOS x64 (Intel, Native AOT)
        - macOS ARM64 (Apple Silicon, Native AOT)

        Features:
        - Multiple TSP algorithms (Nearest Neighbor, 2-Opt, Simulated Annealing, Genetic Algorithm)
        - Comprehensive logging with Serilog (console + file)
        - Interactive and benchmark modes
        - Cross-platform native AOT compilation
        - Docker support
        - Single-file deployment

        Logging Details:
        - Console output for user interaction
        - Detailed file logging in logs/ directory
        - Daily rotating log files (30 day retention)
        - Structured logging for performance analysis
        - Debug-level logging for algorithm internals

        Usage Examples:
        # Interactive mode
        ./TSP-linux-x64-${{ steps.version.outputs.sha }}

        # Check version
        ./TSP-linux-x64-${{ steps.version.outputs.sha }} --version 2>/dev/null || echo "Run interactively"

        # View logs
        ls -la logs/
        tail -f logs/tsp-solver-*.log
        EOF

        # Create checksums
        echo "Creating checksums..."
        cd ./release-assets
        find . -name "TSP-*" -type f -exec sha256sum {} \; > checksums.txt
        cd ..

        echo "Release assets prepared:"
        ls -la ./release-assets/
        echo ""
        echo "Checksums:"
        cat ./release-assets/checksums.txt

    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v${{ steps.version.outputs.full_version }}
        name: TSP Solver v${{ steps.version.outputs.full_version }}
        draft: false
        prerelease: false
        generate_release_notes: true
        fail_on_unmatched_files: false
        files: |
          ./release-assets/*
        body: |
          ## 🚀 TSP Solver v${{ steps.version.outputs.full_version }}

          **Automated Release** - Built from commit [${{ steps.version.outputs.sha }}](${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }})

          ### 📦 Downloads

          | Platform | Download | Size |
          |----------|----------|------|
          | Windows x64 | [`TSP-win-x64-${{ steps.version.outputs.sha }}.exe`](../../releases/download/v${{ steps.version.outputs.full_version }}/TSP-win-x64-${{ steps.version.outputs.sha }}.exe) | Single executable |
          | Linux x64 | [`TSP-linux-x64-${{ steps.version.outputs.sha }}`](../../releases/download/v${{ steps.version.outputs.full_version }}/TSP-linux-x64-${{ steps.version.outputs.sha }}) | Single executable |
          | macOS Intel | [`TSP-osx-x64-${{ steps.version.outputs.sha }}`](../../releases/download/v${{ steps.version.outputs.full_version }}/TSP-osx-x64-${{ steps.version.outputs.sha }}) | Single executable |
          | macOS Apple Silicon | [`TSP-osx-arm64-${{ steps.version.outputs.sha }}`](../../releases/download/v${{ steps.version.outputs.full_version }}/TSP-osx-arm64-${{ steps.version.outputs.sha }}) | Singleexecutable |

          📋 **[version.txt](../../releases/download/v${{ steps.version.outputs.full_version }}/version.txt)** - Release information
          📋 **[checksums.txt](../../releases/download/v${{ steps.version.outputs.full_version }}/checksums.txt)** - SHA256 checksums

          ### ✨ Key Features

          - 🧠 **Multiple Algorithms**: Nearest Neighbor, 2-Opt, Simulated Annealing, Genetic Algorithm
          - 📊 **Comprehensive Logging**: Console + file logging with Serilog
          - 🎯 **Interactive Mode**: Solve custom TSP instances with different city patterns
          - 🏆 **Benchmark Mode**: Compare all algorithms performance
          - 📈 **Performance Tracking**: Detailed metrics and algorithm progress reporting
          - 🐳 **Docker Support**: Containerized execution environment
          - ⚡ **Native AOT**: Fast startup, single-file deployment, no .NET runtime required
          - 🔄 **Cross-Platform**: Windows, Linux, macOS (Intel & ARM64)

          ### 📋 Quick Start

          ```bash
          # Download and run (Linux/macOS example)
          wget https://github.com/kusl/tsp/releases/download/v${{ steps.version.outputs.full_version }}/TSP-linux-x64-${{ steps.version.outputs.sha }}
          chmod +x TSP-linux-x64-${{ steps.version.outputs.sha }}
          ./TSP-linux-x64-${{ steps.version.outputs.sha }}

          # Check logs after running
          ls -la logs/
          ```

          ### 🔄 Recent Changes

          ${{ github.event.head_commit.message }}

          ### 📊 Algorithm Performance

          | Algorithm | Best For | Time Complexity | Quality |
          |-----------|----------|----------------|---------|
          | Nearest Neighbor | Quick results | O(n²) | Good |
          | 2-Opt | Improved solutions | O(n²) per iteration | Better |
          | Simulated Annealing | Avoiding local optima | O(n) per iteration | Very Good |
          | Genetic Algorithm | Large problems | O(p×g×n) | Best |

          ---

          🔧 **Built with**: .NET 9 | Native AOT | Serilog Logging | GitHub Actions
          📝 **License**: MIT | 🐛 **Issues**: [Report here](../../issues)

    - name: Workflow Summary
      if: always()
      run: |
        echo "## Release Workflow Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Version**: ${{ steps.version.outputs.full_version }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit**: ${{ steps.version.outputs.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Release**: [v${{ steps.version.outputs.full_version }}](../../releases/tag/v${{ steps.version.outputs.full_version }})" >> $GITHUB_STEP_SUMMARY
        echo "- **Assets**: $(find ./release-assets -type f | wc -l) files prepared" >> $GITHUB_STEP_SUMMARY

=== CSPROJ FILES ===

--- C:\code\TSP\TravelingSalesman.ConsoleApp\TravelingSalesman.ConsoleApp.csproj ---
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <!-- TargetFramework and other properties inherited from Directory.Build.props -->
  </PropertyGroup>

  <ItemGroup>
    <!-- Package versions managed by Directory.Packages.props -->
    <PackageReference Include="Serilog" />
    <PackageReference Include="Serilog.Extensions.Logging" />
    <PackageReference Include="Serilog.Sinks.Console" />
    <PackageReference Include="Serilog.Sinks.File" />
    <PackageReference Include="Serilog.Formatting.Compact" />
    <PackageReference Include="Microsoft.Extensions.Logging" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\TravelingSalesman.Core\TravelingSalesman.Core.csproj" />
  </ItemGroup>
</Project>

--- C:\code\TSP\TravelingSalesman.Core\TravelingSalesman.Core.csproj ---
<Project Sdk="Microsoft.NET.Sdk">
  <!-- Everything inherited from Directory.Build.props -->

  <ItemGroup>
    <!-- Package version managed by Directory.Packages.props -->
    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" />
  </ItemGroup>
</Project>

--- C:\code\TSP\TravelingSalesman.Tests\TravelingSalesman.Tests.csproj ---
<Project Sdk="Microsoft.NET.Sdk">

  <ItemGroup>
    <PackageReference Include="coverlet.collector">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.NET.Test.Sdk" />
    <PackageReference Include="xunit" />
    <PackageReference Include="xunit.runner.visualstudio">
      <PrivateAssets>all</PrivateAssets>
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\TravelingSalesman.Core\TravelingSalesman.Core.csproj" />
  </ItemGroup>

  <ItemGroup>
    <Using Include="Xunit" />
  </ItemGroup>

</Project>

=== CS FILES ===

--- C:\code\TSP\TravelingSalesman.ConsoleApp\Program.cs ---
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;
using TravelingSalesman.Core;
using Serilog;
using Microsoft.Extensions.Logging;
using Serilog.Extensions.Logging;

namespace TravelingSalesman.ConsoleApp
{
    class Program
    {
        private static ILoggerFactory _loggerFactory = null!;
        private static ILogger<Program> _logger = null!;

        static async Task Main(string[] args)
        {
            // Handle version argument
            if (args.Length > 0 && (args[0] == "--version" || args[0] == "-v"))
            {
                Console.WriteLine($"TSP Solver v{GetAssemblyVersion()}");
                Console.WriteLine($"Built with .NET {Environment.Version}");
                Console.WriteLine($"Runtime: {System.Runtime.InteropServices.RuntimeInformation.RuntimeIdentifier}");
                return;
            }

            // Handle help argument
            if (args.Length > 0 && (args[0] == "--help" || args[0] == "-h"))
            {
                ShowHelp();
                return;
            }

            // Configure Serilog to write to both console and file
            Log.Logger = new LoggerConfiguration()
                .MinimumLevel.Information()
                .MinimumLevel.Override("TravelingSalesman.Core", Serilog.Events.LogEventLevel.Debug)
                .WriteTo.Console(
                    outputTemplate: "[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj}{NewLine}{Exception}")
                .WriteTo.File(
                    path: "logs/tsp-solver-.log",
                    rollingInterval: RollingInterval.Day,
                    retainedFileCountLimit: 30,
                    outputTemplate: "[{Timestamp:yyyy-MM-dd HH:mm:ss.fff zzz} {Level:u3}] {SourceContext} {Message:lj} {Properties:j}{NewLine}{Exception}")
                .Enrich.WithProperty("Application", "TSP-Solver")
                .Enrich.WithProperty("Version", GetAssemblyVersion())
                .CreateLogger();

            // Create Microsoft.Extensions.Logging factory with Serilog
            _loggerFactory = new SerilogLoggerFactory(Log.Logger);
            _logger = _loggerFactory.CreateLogger<Program>();

            _logger.LogInformation("TSP Solver v{Version} starting up", GetAssemblyVersion());

            try
            {
                PrintHeader();

                while (true)
                {
                    var option = ShowMainMenu();
                    _logger.LogDebug("User selected menu option: {Option}", option);

                    switch (option)
                    {
                        case 1:
                            await RunInteractiveSolver();
                            break;
                        case 2:
                            await RunBenchmark();
                            break;
                        case 3:
                            await RunDemonstration();
                            break;
                        case 4:
                            ShowAlgorithmInfo();
                            break;
                        case 5:
                            _logger.LogInformation("User requested application exit");
                            Log.Information("Thank you for using TSP Solver! Goodbye!");
                            return;
                        default:
                            _logger.LogWarning("Invalid menu option selected: {Option}", option);
                            Log.Error("Invalid option. Please try again.");
                            break;
                    }

                    if (option != 5)
                    {
                        Log.Information("Press any key to return to main menu...");
                        Console.ReadKey();
                        Console.WriteLine(); // Still need Console.WriteLine for newline after keypress
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogCritical(ex, "Unexpected error occurred in main application loop");
                Log.Fatal("An unexpected error occurred: {ErrorMessage}", ex.Message);
                Log.Information("Press any key to exit...");
                Console.ReadKey();
            }
            finally
            {
                _logger.LogInformation("TSP Solver shutting down");
                await Log.CloseAndFlushAsync();
            }
        }

        static async Task RunInteractiveSolver()
        {
            _logger.LogInformation("Starting interactive solver session");
            LogSectionHeader("Interactive TSP Solver");

            // Get number of cities
            Log.Information("How many cities? (minimum 2): ");
            if (!int.TryParse(Console.ReadLine(), out int cityCount) || cityCount < 2)
            {
                _logger.LogWarning("Invalid city count input, using default of 10");
                Log.Error("Invalid input. Using default of 10 cities.");
                cityCount = 10;
            }

            _logger.LogInformation("Interactive solver configured for {CityCount} cities", cityCount);

            // Warn for large numbers
            if (cityCount > 100)
            {
                _logger.LogWarning("Large city count requested: {CityCount}", cityCount);
                Log.Warning("⚠️ Note: {CityCount} cities may take significant time with some algorithms.", cityCount);
                Log.Warning("   Nearest Neighbor will be fast, but Genetic Algorithm may take minutes.");
                Log.Information("   Continue? (y/n): ");

                if (Console.ReadLine()?.ToLower() != "y")
                {
                    Log.Information("Using 50 cities instead.");
                    cityCount = 50;
                    _logger.LogInformation("User reduced city count to {CityCount}", cityCount);
                }
            }

            // Select data pattern
            Log.Information("Select city distribution pattern:");
            Log.Information("  1. Random");
            Log.Information("  2. Circular");
            Log.Information("  3. Grid");
            Log.Information("➤ Select pattern (1-3): ");

            var generator = new TspDataGenerator(42, _loggerFactory.CreateLogger<TspDataGenerator>());
            IReadOnlyList<City> cities;
            string pattern;

            var patternChoice = Console.ReadLine();
            switch (patternChoice)
            {
                case "2":
                    cities = generator.GenerateCircularCities(cityCount);
                    pattern = "circular";
                    Log.Information("✓ Generated {CityCount} cities in circular pattern", cityCount);
                    break;
                case "3":
                    var gridSize = (int)Math.Sqrt(cityCount);
                    cities = generator.GenerateGridCities(gridSize, gridSize + (cityCount - gridSize * gridSize) / gridSize + 1);
                    cities = cities.Take(cityCount).ToList();
                    pattern = "grid";
                    Log.Information("✓ Generated {CityCount} cities in grid pattern", cityCount);
                    break;
                default:
                    cities = generator.GenerateRandomCities(cityCount);
                    pattern = "random";
                    Log.Information("✓ Generated {CityCount} random cities", cityCount);
                    break;
            }

            _logger.LogInformation("Generated {CityCount} cities with {Pattern} pattern", cityCount, pattern);

            // Select algorithm
            Log.Information("Select algorithm:");
            Log.Information("  1. Nearest Neighbor (Fast, Good)");
            Log.Information("  2. 2-Opt (Medium, Better)");
            Log.Information("  3. Simulated Annealing (Slow, Very Good)");
            Log.Information("  4. Genetic Algorithm (Slowest, Best)");
            Log.Information("➤ Select algorithm (1-4): ");

            ITspSolver solver;
            var algoChoice = Console.ReadLine();
            switch (algoChoice)
            {
                case "2":
                    solver = new TwoOptSolver(logger: _loggerFactory.CreateLogger<TwoOptSolver>());
                    break;
                case "3":
                    solver = new SimulatedAnnealingSolver(logger: _loggerFactory.CreateLogger<SimulatedAnnealingSolver>());
                    break;
                case "4":
                    solver = GeneticAlgorithmSolver.CreateScaledGeneticSolver(cityCount, logger: _loggerFactory.CreateLogger<GeneticAlgorithmSolver>());
                    break;
                default:
                    solver = new NearestNeighborSolver(_loggerFactory.CreateLogger<NearestNeighborSolver>());
                    break;
            }

            _logger.LogInformation("Selected algorithm: {Algorithm} for {CityCount} cities", solver.Name, cityCount);
            Log.Information("🔄 Running {Algorithm} algorithm...", solver.Name);

            // Setup progress reporting - show dots for visual feedback
            var progressCount = 0;
            solver.ProgressChanged += (s, e) =>
            {
                if (progressCount++ % 10 == 0)
                {
                    Console.Write(".");
                }
            };

            // Solve
            var stopwatch = Stopwatch.StartNew();
            _logger.LogInformation("Starting TSP solution with {Algorithm}", solver.Name);

            var tour = await solver.SolveAsync(cities);
            stopwatch.Stop();

            // Log the results
            _logger.LogInformation("TSP solution completed - Algorithm: {Algorithm}, Cities: {CityCount}, Pattern: {Pattern}, " +
                          "Distance: {Distance:F2}, Time: {TimeMs}ms",
                          solver.Name, cityCount, pattern, tour.TotalDistance, stopwatch.ElapsedMilliseconds);

            // Display results
            Console.WriteLine(); // Clear progress dots
            Console.WriteLine();
            Log.Information(new string('═', 60));
            Log.Information("✓ Solution Found!");
            Log.Information(new string('═', 60));

            Log.Information("Algorithm: {Algorithm}", solver.Name);
            Log.Information("Execution Time: {TimeMs:N0} ms", stopwatch.ElapsedMilliseconds);
            Log.Information("Total Distance: {Distance:F2} units", tour.TotalDistance);
            Log.Information("Route ({CityCount} cities):", tour.Cities.Count);

            var routeStr = string.Join(" → ", tour.Cities.Take(Math.Min(10, tour.Cities.Count)).Select(c => c.Name));
            if (tour.Cities.Count > 10)
            {
                routeStr += " → ... → " + tour.Cities.Last().Name;
            }
            routeStr += " → " + tour.Cities[0].Name;

            Log.Information(routeStr);

            // Show city coordinates if requested
            Log.Information("Show city coordinates? (y/n): ");
            if (Console.ReadLine()?.ToLower() == "y")
            {
                Log.Information("City Coordinates:");
                foreach (var city in cities.Take(Math.Min(20, cities.Count)))
                {
                    Log.Information("  {CityName}: ({X:F2}, {Y:F2})", city.Name, city.X, city.Y);
                }
                if (cities.Count > 20)
                {
                    Log.Information("  ... and {AdditionalCount} more cities", cities.Count - 20);
                }
            }

            _logger.LogInformation("Interactive solver session completed successfully");
        }

        static async Task RunBenchmark()
        {
            _logger.LogInformation("Starting benchmark session");
            LogSectionHeader("Algorithm Benchmark");

            Log.Information("Number of cities for benchmark: ");
            if (!int.TryParse(Console.ReadLine(), out int cityCount) || cityCount < 2)
            {
                cityCount = 15;
                Log.Information("Invalid input. Using default of {CityCount} cities.", cityCount);
                _logger.LogWarning("Invalid benchmark city count, using default: {CityCount}", cityCount);
            }

            if (cityCount > 50)
            {
                Log.Warning("⚠️ Benchmark with {CityCount} cities may take several minutes.", cityCount);
                _logger.LogWarning("Large benchmark requested: {CityCount} cities", cityCount);
            }

            var generator = new TspDataGenerator(logger: _loggerFactory.CreateLogger<TspDataGenerator>());
            var cities = generator.GenerateRandomCities(cityCount);

            _logger.LogInformation("Generated {CityCount} random cities for benchmark", cityCount);

            Log.Information("🔄 Running benchmark with {CityCount} cities...", cityCount);
            Log.Information("This may take a moment...");

            var benchmark = new TspBenchmark(_loggerFactory.CreateLogger<TspBenchmark>());
            var solvers = new List<ITspSolver>
            {
                new NearestNeighborSolver(_loggerFactory.CreateLogger<NearestNeighborSolver>()),
                new TwoOptSolver(maxIterations: cityCount * 10, logger: _loggerFactory.CreateLogger<TwoOptSolver>()),
                new SimulatedAnnealingSolver(
                    initialTemperature: cityCount * 100,
                    coolingRate: 0.9995,
                    iterationsPerTemperature: cityCount * 10,
                    logger: _loggerFactory.CreateLogger<SimulatedAnnealingSolver>()),
                new GeneticAlgorithmSolver(
                    populationSize: Math.Max(200, cityCount * 2),
                    generations: Math.Min(5000, cityCount * 20),
                    mutationRate: 0.1,
                    elitismRate: 0.1,
                    logger: _loggerFactory.CreateLogger<GeneticAlgorithmSolver>())
            };

            Console.Write("Processing: ");
            var stopwatch = Stopwatch.StartNew();
            var results = await benchmark.RunBenchmarkAsync(cities, solvers);
            stopwatch.Stop();

            Console.WriteLine(" Done!");

            // Log detailed benchmark results
            _logger.LogInformation("Benchmark completed - Cities: {CityCount}, TotalTime: {TotalTimeMs}ms",
                cityCount, stopwatch.ElapsedMilliseconds);

            foreach (var result in results)
            {
                _logger.LogInformation("Benchmark result - Algorithm: {Algorithm}, Distance: {Distance:F2}, " +
                              "Time: {TimeMs}ms, Rank: {Rank}",
                              result.SolverName, result.Distance, result.ExecutionTime.TotalMilliseconds,
                              results.ToList().IndexOf(result) + 1);
            }

            Log.Information(benchmark.FormatResults(results));

            // Display winner details
            var winner = results.First();
            Log.Information("🏆 Winner: {SolverName}", winner.SolverName);
            Log.Information("   Distance: {Distance:F2}", winner.Distance);
            Log.Information("   Time: {TimeMs:F1} ms", winner.ExecutionTime.TotalMilliseconds);

            _logger.LogInformation("Benchmark session completed - Winner: {Winner}, Distance: {Distance:F2}",
                winner.SolverName, winner.Distance);
        }

        static async Task RunDemonstration()
        {
            _logger.LogInformation("Starting demonstration session");
            LogSectionHeader("Visual Algorithm Demonstration");

            Log.Information("This demonstration will show how different algorithms");
            Log.Information("approach the TSP problem step by step.");

            var generator = new TspDataGenerator(42, _loggerFactory.CreateLogger<TspDataGenerator>());
            var cities = generator.GenerateCircularCities(8); // Small number for clarity

            Log.Information("Generated {CityCount} cities in a circular pattern.", cities.Count);
            Log.Information("Cities:");
            foreach (var city in cities)
            {
                Log.Information("  {CityName}: ({X:F1}, {Y:F1})", city.Name, city.X, city.Y);
            }

            Log.Information("Press any key to start the demonstration...");
            Console.ReadKey();
            Console.WriteLine(); // Add newline after keypress

            // Demonstrate each algorithm
            var algorithms = new (string name, ITspSolver solver)[]
            {
                ("Nearest Neighbor", new NearestNeighborSolver(_loggerFactory.CreateLogger<NearestNeighborSolver>())),
                ("2-Opt Improvement", new TwoOptSolver(100, _loggerFactory.CreateLogger<TwoOptSolver>())),
                ("Simulated Annealing", new SimulatedAnnealingSolver(1000, 0.99, 50, logger: _loggerFactory.CreateLogger<SimulatedAnnealingSolver>())),
                ("Genetic Algorithm", new GeneticAlgorithmSolver(20, 50, 0.05, 0.3, logger: _loggerFactory.CreateLogger<GeneticAlgorithmSolver>()))
            };

            foreach (var (name, solver) in algorithms)
            {
                _logger.LogInformation("Running demonstration for {Algorithm}", name);
                Log.Information(new string('─', 60));
                LogSectionHeader($"Algorithm: {name}");

                Log.Information("🔄 Running {Algorithm}...", name);

                var iterations = new List<(int iteration, double distance, string message)>();
                solver.ProgressChanged += (s, e) =>
                {
                    iterations.Add((e.Iteration, e.CurrentBestDistance, e.Message));
                };

                var tour = await solver.SolveAsync(cities);

                // Display progress summary
                if (iterations.Count > 0)
                {
                    Log.Information("Algorithm Progress Summary:");
                    Log.Information(new string('-', 50));

                    var first = iterations.First();
                    var last = iterations.Last();
                    var best = iterations.MinBy(i => i.distance);

                    Log.Information("  Initial: Distance = {Distance:F2}", first.distance);
                    if (iterations.Count > 2)
                    {
                        Log.Information("  Best:    Distance = {Distance:F2} (at iteration {Iteration})", best.distance, best.iteration);
                    }
                    Log.Information("  Final:   Distance = {Distance:F2}", last.distance);
                    Log.Information("  Total iterations: {IterationCount}", iterations.Count);
                }

                Log.Information(new string('-', 50));
                Log.Information("✓ Final Solution:");
                Log.Information("  Distance: {Distance:F2}", tour.TotalDistance);
                Log.Information("  Route: {Route} → {FirstCity}", string.Join(" → ", tour.Cities.Select(c => c.Name)), tour.Cities[0].Name);

                DrawSimpleVisualization(tour);

                if (algorithms.Last() != (name, solver))
                {
                    Log.Information("Press any key for next algorithm...");
                    Console.ReadKey();
                    Console.WriteLine(); // Add newline after keypress
                }
            }

            Log.Information(new string('═', 60));
            Log.Information("Demonstration Complete! All algorithms have been demonstrated.");
            _logger.LogInformation("Demonstration session completed successfully");
        }

        static void ShowAlgorithmInfo()
        {
            _logger.LogInformation("Displaying algorithm information");
            LogSectionHeader("Algorithm Information");

            var info = new Dictionary<string, (string complexity, string pros, string cons, string description)>
            {
                ["Nearest Neighbor"] = (
                    "O(n²)",
                    "Fast, simple, deterministic",
                    "Can produce suboptimal solutions",
                    "Builds tour by always visiting the nearest unvisited city."
                ),
                ["2-Opt"] = (
                    "O(n²) per iteration",
                    "Good improvement over initial solution",
                    "Can get stuck in local optima",
                    "Improves existing tour by reversing segments to reduce crossings."
                ),
                ["Simulated Annealing"] = (
                    "O(n) per iteration × iterations",
                    "Can escape local optima, tunable parameters",
                    "Slower, non-deterministic",
                    "Uses controlled randomness to explore solution space, accepting worse solutions probabilistically."
                ),
                ["Genetic Algorithm"] = (
                    "O(p×g×n) where p=population, g=generations",
                    "Excellent for large problems, parallelizable",
                    "Slowest, many parameters to tune",
                    "Evolves population of solutions using selection, crossover, and mutation."
                )
            };

            foreach (var (algo, (complexity, pros, cons, description)) in info)
            {
                Log.Information("📍 {Algorithm}", algo);
                Log.Information(new string('-', 40));
                Log.Information("Description: {Description}", description);
                Log.Information("Complexity:  {Complexity}", complexity);
                Log.Information("Pros:        {Pros}", pros);
                Log.Information("Cons:        {Cons}", cons);
            }

            Log.Information(new string('═', 60));
            Log.Information("💡 Recommendations:");
            Log.Information("  • Small problems (< 20 cities): Nearest Neighbor + 2-Opt");
            Log.Information("  • Medium problems (20-100 cities): Simulated Annealing");
            Log.Information("  • Large problems (> 100 cities): Genetic Algorithm");
            Log.Information("  • Real-time requirements: Nearest Neighbor");
            Log.Information("  • Best quality: Genetic Algorithm with tuned parameters");
        }

        static void DrawSimpleVisualization(Tour tour)
        {
            Log.Information("Simple ASCII Visualization:");
            Log.Information(new string('─', 50));

            const int width = 40;
            const int height = 10;
            var grid = new char[height, width];

            // Initialize grid
            for (int i = 0; i < height; i++)
                for (int j = 0; j < width; j++)
                    grid[i, j] = ' ';

            // Normalize coordinates to fit grid
            var minX = tour.Cities.Min(c => c.X);
            var maxX = tour.Cities.Max(c => c.X);
            var minY = tour.Cities.Min(c => c.Y);
            var maxY = tour.Cities.Max(c => c.Y);

            foreach (var city in tour.Cities)
            {
                var x = (int)((city.X - minX) / (maxX - minX) * (width - 1));
                var y = (int)((city.Y - minY) / (maxY - minY) * (height - 1));

                if (x >= 0 && x < width && y >= 0 && y < height)
                {
                    grid[height - 1 - y, x] = '●';
                }
            }

            // Draw grid
            for (int i = 0; i < height; i++)
            {
                var line = "  ";
                for (int j = 0; j < width; j++)
                {
                    line += grid[i, j];
                }
                Log.Information(line);
            }

            Log.Information(new string('─', 50));
        }

        // Solution 3: Dynamic box sizing (recommended)
        static void PrintHeader()
        {
            Console.WriteLine(); // Space from previous output

            var version = GetAssemblyVersion();
            var titleLine = $"TRAVELING SALESMAN PROBLEM SOLVER v{version}";
            var subtitleLine = ".NET 9 Implementation";

            // Determine the width needed
            var maxLength = Math.Max(titleLine.Length, subtitleLine.Length);
            var boxWidth = Math.Max(maxLength + 4, 65); // At least 65 chars wide, or content + padding

            var topBorder = "╔" + new string('═', boxWidth - 2) + "╗";
            var bottomBorder = "╚" + new string('═', boxWidth - 2) + "╝";

            // Center the text
            var titlePadding = (boxWidth - 2 - titleLine.Length) / 2;
            var titleRightPad = (boxWidth - 2) - titleLine.Length - titlePadding;

            var subtitlePadding = (boxWidth - 2 - subtitleLine.Length) / 2;
            var subtitleRightPad = (boxWidth - 2) - subtitleLine.Length - subtitlePadding;

            Log.Information(topBorder);
            Log.Information("║{0}{1}{2}║",
                new string(' ', titlePadding),
                titleLine,
                new string(' ', titleRightPad));
            Log.Information("║{0}{1}{2}║",
                new string(' ', subtitlePadding),
                subtitleLine,
                new string(' ', subtitleRightPad));
            Log.Information(bottomBorder);
        }

        static int ShowMainMenu()
        {
            Log.Information("📍 Main Menu:");
            Log.Information("");
            Log.Information("  1. Interactive Solver - Solve custom TSP instances");
            Log.Information("  2. Algorithm Benchmark - Compare all algorithms");
            Log.Information("  3. Visual Demonstration - See algorithms in action");
            Log.Information("  4. Algorithm Information - Learn about each algorithm");
            Log.Information("  5. Exit");

            Log.Information("➤ Select an option (1-5): ");

            if (int.TryParse(Console.ReadLine(), out int option))
            {
                return option;
            }

            return -1;
        }

        static void LogSectionHeader(string title)
        {
            Log.Information(new string('═', 60));
            Log.Information("  {Title}", title);
            Log.Information(new string('═', 60));
        }

        static string GetAssemblyVersion()
        {
            var version = System.Reflection.Assembly.GetExecutingAssembly().GetName().Version;
            return version?.ToString(3) ?? "1.2.0";
        }

        static void ShowHelp()
        {
            Console.WriteLine("TSP Solver - Traveling Salesman Problem Solver");
            Console.WriteLine();
            Console.WriteLine("Usage: TSP-solver [options]");
            Console.WriteLine();
            Console.WriteLine("Options:");
            Console.WriteLine("  --version, -v    Show version information");
            Console.WriteLine("  --help, -h       Show this help message");
            Console.WriteLine();
            Console.WriteLine("Interactive mode will start if no options are provided.");
            Console.WriteLine("Logs are written to the 'logs/' directory.");
        }
    }
}

--- C:\code\TSP\TravelingSalesman.Core\TravelingSalesmanLibrary.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;

namespace TravelingSalesman.Core
{
    /// <summary>
    /// Represents a city in the TSP problem
    /// </summary>
    public sealed record City(int Id, string Name, double X, double Y)
    {
        public double DistanceTo(City other)
        {
            var dx = X - other.X;
            var dy = Y - other.Y;
            return Math.Sqrt(dx * dx + dy * dy);
        }
    }

    /// <summary>
    /// Represents a tour through cities
    /// </summary>
    public sealed class Tour
    {
        private readonly List<City> _cities;
        private readonly double[,] _distanceMatrix;
        private readonly ILogger<Tour> _logger;
        private double? _cachedDistance;

        public IReadOnlyList<City> Cities => _cities.AsReadOnly();
        public double TotalDistance => _cachedDistance ??= CalculateTotalDistance();

        public Tour(IEnumerable<City> cities, double[,] distanceMatrix, ILogger<Tour>? logger = null)
        {
            _cities = cities.ToList();
            _distanceMatrix = distanceMatrix;
            _logger = logger ?? NullLogger<Tour>.Instance;
        }

        private double CalculateTotalDistance()
        {
            if (_cities.Count < 2)
            {
                _logger.LogDebug("Tour has less than 2 cities, returning distance 0");
                return 0;
            }

            var distance = 0.0;
            for (int i = 0; i < _cities.Count - 1; i++)
            {
                distance += _distanceMatrix[_cities[i].Id, _cities[i + 1].Id];
            }
            // Return to start
            distance += _distanceMatrix[_cities[^1].Id, _cities[0].Id];

            _logger.LogTrace("Calculated total distance: {Distance:F2} for {CityCount} cities", distance, _cities.Count);
            return distance;
        }

        public Tour Clone(ILogger<Tour>? logger = null) => new Tour(_cities, _distanceMatrix, logger ?? _logger);

        public void SwapCities(int index1, int index2)
        {
            if (index1 == index2) return;

            var city1 = _cities[index1];
            var city2 = _cities[index2];

            (_cities[index1], _cities[index2]) = (_cities[index2], _cities[index1]);
            _cachedDistance = null;

            _logger.LogTrace("Swapped cities {City1} and {City2}", city1.Name, city2.Name);
        }

        public void Reverse(int start, int end)
        {
            _logger.LogTrace("Reversing tour segment from index {Start} to {End}", start, end);
            while (start < end)
            {
                SwapCities(start, end);
                start++;
                end--;
            }
        }

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.AppendLine($"Tour Distance: {TotalDistance:F2}");
            sb.AppendLine("Route:");
            foreach (var city in _cities)
            {
                sb.Append($"{city.Name} -> ");
            }
            sb.Append(_cities[0].Name); // Return to start
            return sb.ToString();
        }
    }

    /// <summary>
    /// Interface for TSP solving algorithms
    /// </summary>
    public interface ITspSolver
    {
        string Name { get; }
        Task<Tour> SolveAsync(IReadOnlyList<City> cities, CancellationToken cancellationToken = default);
        event EventHandler<TspProgressEventArgs>? ProgressChanged;
    }

    /// <summary>
    /// Event args for progress reporting
    /// </summary>
    public sealed class TspProgressEventArgs : EventArgs
    {
        public int Iteration { get; init; }
        public double CurrentBestDistance { get; init; }
        public string Message { get; init; } = string.Empty;
    }

    /// <summary>
    /// Base class for TSP solvers
    /// </summary>
    public abstract class TspSolverBase : ITspSolver
    {
        protected readonly ILogger _logger;

        protected TspSolverBase(ILogger? logger = null)
        {
            _logger = logger ?? NullLogger.Instance;
        }

        public abstract string Name { get; }
        public event EventHandler<TspProgressEventArgs>? ProgressChanged;

        protected double[,] BuildDistanceMatrix(IReadOnlyList<City> cities)
        {
            var n = cities.Count;
            var matrix = new double[n, n];

            _logger.LogDebug("Building distance matrix for {CityCount} cities", n);

            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < n; j++)
                {
                    matrix[i, j] = cities[i].DistanceTo(cities[j]);
                }
            }

            _logger.LogDebug("Distance matrix built successfully");
            return matrix;
        }

        protected void OnProgressChanged(int iteration, double currentBest, string message = "")
        {
            _logger.LogTrace("Algorithm progress: Iteration {Iteration}, Best Distance {Distance:F2}, Message: {Message}",
                iteration, currentBest, message);

            ProgressChanged?.Invoke(this, new TspProgressEventArgs
            {
                Iteration = iteration,
                CurrentBestDistance = currentBest,
                Message = message
            });
        }

        public abstract Task<Tour> SolveAsync(IReadOnlyList<City> cities, CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Nearest Neighbor heuristic solver
    /// </summary>
    public sealed class NearestNeighborSolver : TspSolverBase
    {
        public override string Name => "Nearest Neighbor";

        public NearestNeighborSolver(ILogger<NearestNeighborSolver>? logger = null) : base(logger)
        {
        }

        public override Task<Tour> SolveAsync(IReadOnlyList<City> cities, CancellationToken cancellationToken = default)
        {
            return Task.Run(() =>
            {
                _logger.LogInformation("Starting Nearest Neighbor algorithm for {CityCount} cities", cities.Count);

                if (cities.Count < 2)
                {
                    _logger.LogWarning("Less than 2 cities provided, returning minimal tour");
                    return new Tour(cities, BuildDistanceMatrix(cities));
                }

                var distanceMatrix = BuildDistanceMatrix(cities);
                var visited = new bool[cities.Count];
                var route = new List<City> { cities[0] };
                visited[0] = true;

                var current = 0;
                for (int i = 1; i < cities.Count; i++)
                {
                    cancellationToken.ThrowIfCancellationRequested();

                    var nearest = -1;
                    var nearestDistance = double.MaxValue;

                    for (int j = 0; j < cities.Count; j++)
                    {
                        if (!visited[j] && distanceMatrix[current, j] < nearestDistance)
                        {
                            nearest = j;
                            nearestDistance = distanceMatrix[current, j];
                        }
                    }

                    if (nearest != -1)
                    {
                        visited[nearest] = true;
                        route.Add(cities[nearest]);
                        current = nearest;

                        _logger.LogTrace("Added city {CityName} (distance: {Distance:F2})", cities[nearest].Name, nearestDistance);
                    }

                    OnProgressChanged(i, new Tour(route, distanceMatrix).TotalDistance, $"Added city {cities[current].Name}");
                }

                var finalTour = new Tour(route, distanceMatrix);
                _logger.LogInformation("Nearest Neighbor completed: Distance {Distance:F2}", finalTour.TotalDistance);

                return finalTour;
            }, cancellationToken);
        }
    }

    /// <summary>
    /// 2-Opt local search improvement solver
    /// </summary>
    public sealed class TwoOptSolver : TspSolverBase
    {
        private readonly int _maxIterations;

        public override string Name => "2-Opt";

        public TwoOptSolver(int maxIterations = 1000, ILogger<TwoOptSolver>? logger = null) : base(logger)
        {
            _maxIterations = maxIterations;
        }

        public override async Task<Tour> SolveAsync(IReadOnlyList<City> cities, CancellationToken cancellationToken = default)
        {
            _logger.LogInformation("Starting 2-Opt algorithm for {CityCount} cities (max iterations: {MaxIterations})",
                cities.Count, _maxIterations);

            // Start with nearest neighbor solution
            var nnSolver = new NearestNeighborSolver(_logger as ILogger<NearestNeighborSolver>);
            var tour = await nnSolver.SolveAsync(cities, cancellationToken);

            _logger.LogDebug("Initial tour from Nearest Neighbor: {Distance:F2}", tour.TotalDistance);

            return await Task.Run(() => Improve2Opt(tour, cancellationToken), cancellationToken);
        }

        private Tour Improve2Opt(Tour tour, CancellationToken cancellationToken)
        {
            var improved = true;
            var iteration = 0;
            var bestTour = tour.Clone();
            var initialDistance = bestTour.TotalDistance;

            _logger.LogDebug("Starting 2-Opt improvement from distance {InitialDistance:F2}", initialDistance);

            while (improved && iteration < _maxIterations)
            {
                cancellationToken.ThrowIfCancellationRequested();
                improved = false;

                for (int i = 1; i < tour.Cities.Count - 2; i++)
                {
                    for (int j = i + 1; j < tour.Cities.Count; j++)
                    {
                        cancellationToken.ThrowIfCancellationRequested();

                        // Try reversing the tour between i and j
                        var newTour = bestTour.Clone();
                        newTour.Reverse(i, j);

                        if (newTour.TotalDistance < bestTour.TotalDistance)
                        {
                            _logger.LogTrace("2-Opt improvement found: {OldDistance:F2} -> {NewDistance:F2}",
                                bestTour.TotalDistance, newTour.TotalDistance);
                            bestTour = newTour;
                            improved = true;
                        }
                    }
                }

                iteration++;
                OnProgressChanged(iteration, bestTour.TotalDistance, $"2-Opt iteration {iteration}");
            }

            var finalImprovement = ((initialDistance - bestTour.TotalDistance) / initialDistance) * 100;
            _logger.LogInformation("2-Opt completed after {Iterations} iterations. " +
                                 "Distance: {FinalDistance:F2} (improved by {Improvement:F1}%)",
                                 iteration, bestTour.TotalDistance, finalImprovement);

            return bestTour;
        }
    }

    /// <summary>
    /// Simulated Annealing solver for TSP
    /// </summary>
    public sealed class SimulatedAnnealingSolver : TspSolverBase
    {
        private readonly double _initialTemperature;
        private readonly double _coolingRate;
        private readonly int _iterationsPerTemperature;
        private readonly Random _random;

        public override string Name => "Simulated Annealing";

        public SimulatedAnnealingSolver(
            double initialTemperature = 10000,
            double coolingRate = 0.9995,
            int iterationsPerTemperature = 1000,
            int? seed = null,
            ILogger<SimulatedAnnealingSolver>? logger = null) : base(logger)
        {
            _initialTemperature = initialTemperature;
            _coolingRate = coolingRate;
            _iterationsPerTemperature = iterationsPerTemperature;
            _random = seed.HasValue ? new Random(seed.Value) : new Random();
        }

        public override async Task<Tour> SolveAsync(IReadOnlyList<City> cities, CancellationToken cancellationToken = default)
        {
            _logger.LogInformation("Starting Simulated Annealing for {CityCount} cities " +
                                 "(temp: {InitialTemp}, cooling: {CoolingRate}, iterations per temp: {IterationsPerTemp})",
                                 cities.Count, _initialTemperature, _coolingRate, _iterationsPerTemperature);

            // Start with nearest neighbor solution
            var nnSolver = new NearestNeighborSolver(_logger as ILogger<NearestNeighborSolver>);
            var initialTour = await nnSolver.SolveAsync(cities, cancellationToken);

            return await Task.Run(() => RunSimulatedAnnealing(initialTour, cancellationToken), cancellationToken);
        }

        private Tour RunSimulatedAnnealing(Tour initialTour, CancellationToken cancellationToken)
        {
            var currentTour = initialTour.Clone();
            var bestTour = currentTour.Clone();
            var temperature = _initialTemperature;
            var iteration = 0;
            var acceptedMoves = 0;
            var rejectedMoves = 0;
            var initialDistance = initialTour.TotalDistance;

            _logger.LogDebug("Starting SA from initial distance: {InitialDistance:F2}", initialDistance);

            while (temperature > 0.1)
            {
                for (int i = 0; i < _iterationsPerTemperature; i++)
                {
                    cancellationToken.ThrowIfCancellationRequested();

                    var newTour = currentTour.Clone();

                    // Random perturbation: swap two random cities
                    var index1 = _random.Next(1, newTour.Cities.Count);
                    var index2 = _random.Next(1, newTour.Cities.Count);

                    if (index1 != index2)
                    {
                        newTour.SwapCities(index1, index2);

                        var deltaDistance = newTour.TotalDistance - currentTour.TotalDistance;

                        // Accept or reject the new solution
                        if (deltaDistance < 0 || _random.NextDouble() < Math.Exp(-deltaDistance / temperature))
                        {
                            currentTour = newTour;
                            acceptedMoves++;

                            if (currentTour.TotalDistance < bestTour.TotalDistance)
                            {
                                bestTour = currentTour.Clone();
                                _logger.LogTrace("New best solution found: {Distance:F2} at temperature {Temperature:F2}",
                                    bestTour.TotalDistance, temperature);
                            }
                        }
                        else
                        {
                            rejectedMoves++;
                        }
                    }

                    iteration++;
                    if (iteration % 1000 == 0)
                    {
                        OnProgressChanged(iteration, bestTour.TotalDistance,
                            $"Temperature: {temperature:F2}, Best: {bestTour.TotalDistance:F2}");
                    }
                }

                temperature *= _coolingRate;
            }

            var finalImprovement = ((initialDistance - bestTour.TotalDistance) / initialDistance) * 100;
            var acceptanceRate = (double)acceptedMoves / (acceptedMoves + rejectedMoves) * 100;

            _logger.LogInformation("Simulated Annealing completed after {Iterations} iterations. " +
                                 "Distance: {FinalDistance:F2} (improved by {Improvement:F1}%). " +
                                 "Acceptance rate: {AcceptanceRate:F1}%",
                                 iteration, bestTour.TotalDistance, finalImprovement, acceptanceRate);

            return bestTour;
        }
    }

    /// <summary>
    /// Genetic Algorithm solver for TSP
    /// </summary>
    public sealed class GeneticAlgorithmSolver : TspSolverBase
    {
        private readonly int _populationSize;
        private readonly int _generations;
        private readonly double _mutationRate;
        private readonly double _elitismRate;
        private readonly Random _random;

        public override string Name => "Genetic Algorithm";

        public GeneticAlgorithmSolver(
            int populationSize = 100,
            int generations = 500,
            double mutationRate = 0.02,
            double elitismRate = 0.2,
            int? seed = null,
            ILogger<GeneticAlgorithmSolver>? logger = null) : base(logger)
        {
            _populationSize = populationSize;
            _generations = generations;
            _mutationRate = mutationRate;
            _elitismRate = elitismRate;
            _random = seed.HasValue ? new Random(seed.Value) : new Random();
        }

        public static GeneticAlgorithmSolver CreateScaledGeneticSolver(int cityCount, int? seed = null, ILogger<GeneticAlgorithmSolver>? logger = null)
        {
            return new GeneticAlgorithmSolver(
                populationSize: Math.Max(200, cityCount * 2),
                generations: Math.Max(1000, cityCount * 10),
                mutationRate: 0.1,
                elitismRate: 0.1,
                seed: seed,
                logger: logger
            );
        }

        public override Task<Tour> SolveAsync(IReadOnlyList<City> cities, CancellationToken cancellationToken = default)
        {
            _logger.LogInformation("Starting Genetic Algorithm for {CityCount} cities " +
                                 "(population: {Population}, generations: {Generations}, " +
                                 "mutation rate: {MutationRate:F3}, elitism rate: {ElitismRate:F3})",
                                 cities.Count, _populationSize, _generations, _mutationRate, _elitismRate);

            return Task.Run(() => RunGeneticAlgorithm(cities, cancellationToken), cancellationToken);
        }

        private Tour RunGeneticAlgorithm(IReadOnlyList<City> cities, CancellationToken cancellationToken)
        {
            var distanceMatrix = BuildDistanceMatrix(cities);
            var population = InitializePopulation(cities, distanceMatrix);
            var bestTour = population.OrderBy(t => t.TotalDistance).First();
            var initialBest = bestTour.TotalDistance;
            var generationsWithoutImprovement = 0;

            _logger.LogDebug("Initial population created. Best distance: {BestDistance:F2}", initialBest);

            for (int generation = 0; generation < _generations; generation++)
            {
                cancellationToken.ThrowIfCancellationRequested();

                population = EvolvePopulation(population, distanceMatrix);

                var generationBest = population.OrderBy(t => t.TotalDistance).First();
                if (generationBest.TotalDistance < bestTour.TotalDistance)
                {
                    _logger.LogDebug("Generation {Generation}: New best solution {Distance:F2}",
                        generation, generationBest.TotalDistance);
                    bestTour = generationBest.Clone();
                    generationsWithoutImprovement = 0;
                }
                else
                {
                    generationsWithoutImprovement++;
                }

                if (generation % 50 == 0)
                {
                    OnProgressChanged(generation, bestTour.TotalDistance,
                        $"Generation {generation}, Best: {bestTour.TotalDistance:F2}");
                }

                // Early stopping if no improvement for many generations
                if (generationsWithoutImprovement > _generations / 4)
                {
                    _logger.LogDebug("Early stopping at generation {Generation} due to no improvement", generation);
                    break;
                }
            }

            var finalImprovement = ((initialBest - bestTour.TotalDistance) / initialBest) * 100;
            _logger.LogInformation("Genetic Algorithm completed. " +
                                 "Distance: {FinalDistance:F2} (improved by {Improvement:F1}%)",
                                 bestTour.TotalDistance, finalImprovement);

            return bestTour;
        }

        private List<Tour> InitializePopulation(IReadOnlyList<City> cities, double[,] distanceMatrix)
        {
            var population = new List<Tour>();

            _logger.LogDebug("Initializing population of {PopulationSize} individuals", _populationSize);

            for (int i = 0; i < _populationSize; i++)
            {
                var shuffled = cities.Skip(1).OrderBy(_ => _random.Next()).ToList();
                shuffled.Insert(0, cities[0]); // Keep first city fixed
                population.Add(new Tour(shuffled, distanceMatrix));
            }

            return population;
        }

        private List<Tour> EvolvePopulation(List<Tour> population, double[,] distanceMatrix)
        {
            var newPopulation = new List<Tour>();

            // Keep elite individuals
            var eliteCount = (int)(_populationSize * _elitismRate);
            var elite = population.OrderBy(t => t.TotalDistance).Take(eliteCount).ToList();
            newPopulation.AddRange(elite.Select(t => t.Clone()));

            // Fill rest with offspring
            while (newPopulation.Count < _populationSize)
            {
                var parent1 = TournamentSelection(population);
                var parent2 = TournamentSelection(population);
                var child = Crossover(parent1, parent2, distanceMatrix);

                if (_random.NextDouble() < _mutationRate)
                {
                    Mutate(child);
                }

                newPopulation.Add(child);
            }

            return newPopulation;
        }

        private Tour TournamentSelection(List<Tour> population, int tournamentSize = 5)
        {
            var tournament = new List<Tour>();

            for (int i = 0; i < tournamentSize; i++)
            {
                tournament.Add(population[_random.Next(population.Count)]);
            }

            return tournament.OrderBy(t => t.TotalDistance).First();
        }

        private Tour Crossover(Tour parent1, Tour parent2, double[,] distanceMatrix)
        {
            var cities = parent1.Cities.ToList();
            var start = _random.Next(1, cities.Count - 1);
            var end = _random.Next(start + 1, cities.Count);

            var childCities = new List<City> { cities[0] }; // Keep first city fixed
            var segment = parent1.Cities.Skip(start).Take(end - start).ToList();

            foreach (var city in segment)
            {
                if (city.Id != 0) // Skip first city
                    childCities.Add(city);
            }

            foreach (var city in parent2.Cities)
            {
                if (!childCities.Contains(city) && city.Id != 0)
                {
                    childCities.Add(city);
                }
            }

            return new Tour(childCities, distanceMatrix);
        }

        private void Mutate(Tour tour)
        {
            var index1 = _random.Next(1, tour.Cities.Count);
            var index2 = _random.Next(1, tour.Cities.Count);

            if (index1 != index2)
            {
                tour.SwapCities(index1, index2);
            }
        }
    }

    /// <summary>
    /// Factory for creating TSP solvers with logging
    /// </summary>
    public static class TspSolverFactory
    {
        public enum SolverType
        {
            NearestNeighbor,
            TwoOpt,
            SimulatedAnnealing,
            GeneticAlgorithm
        }

        public static ITspSolver CreateSolver(SolverType type, ILoggerFactory? loggerFactory = null)
        {
            return type switch
            {
                SolverType.NearestNeighbor => new NearestNeighborSolver(loggerFactory?.CreateLogger<NearestNeighborSolver>()),
                SolverType.TwoOpt => new TwoOptSolver(logger: loggerFactory?.CreateLogger<TwoOptSolver>()),
                SolverType.SimulatedAnnealing => new SimulatedAnnealingSolver(logger: loggerFactory?.CreateLogger<SimulatedAnnealingSolver>()),
                SolverType.GeneticAlgorithm => new GeneticAlgorithmSolver(logger: loggerFactory?.CreateLogger<GeneticAlgorithmSolver>()),
                _ => throw new ArgumentException($"Unknown solver type: {type}")
            };
        }

        public static IEnumerable<ITspSolver> CreateAllSolvers(ILoggerFactory? loggerFactory = null)
        {
            yield return new NearestNeighborSolver(loggerFactory?.CreateLogger<NearestNeighborSolver>());
            yield return new TwoOptSolver(logger: loggerFactory?.CreateLogger<TwoOptSolver>());
            yield return new SimulatedAnnealingSolver(logger: loggerFactory?.CreateLogger<SimulatedAnnealingSolver>());
            yield return new GeneticAlgorithmSolver(logger: loggerFactory?.CreateLogger<GeneticAlgorithmSolver>());
        }
    }

    /// <summary>
    /// Service for generating test data
    /// </summary>
    public sealed class TspDataGenerator
    {
        private readonly Random _random;
        private readonly ILogger<TspDataGenerator> _logger;

        public TspDataGenerator(int? seed = null, ILogger<TspDataGenerator>? logger = null)
        {
            _random = seed.HasValue ? new Random(seed.Value) : new Random();
            _logger = logger ?? NullLogger<TspDataGenerator>.Instance;
        }

        public IReadOnlyList<City> GenerateRandomCities(int count, double maxX = 100, double maxY = 100)
        {
            _logger.LogDebug("Generating {Count} random cities in area {MaxX}x{MaxY}", count, maxX, maxY);

            var cities = new List<City>();

            for (int i = 0; i < count; i++)
            {
                cities.Add(new City(
                    i,
                    $"City_{i}",
                    _random.NextDouble() * maxX,
                    _random.NextDouble() * maxY
                ));
            }

            _logger.LogInformation("Generated {Count} random cities", count);
            return cities;
        }

        public IReadOnlyList<City> GenerateCircularCities(int count, double radius = 50, double centerX = 50, double centerY = 50)
        {
            _logger.LogDebug("Generating {Count} cities in circular pattern (radius: {Radius})", count, radius);

            var cities = new List<City>();
            var angleStep = 2 * Math.PI / count;

            for (int i = 0; i < count; i++)
            {
                var angle = i * angleStep;
                cities.Add(new City(
                    i,
                    $"City_{i}",
                    centerX + radius * Math.Cos(angle),
                    centerY + radius * Math.Sin(angle)
                ));
            }

            _logger.LogInformation("Generated {Count} cities in circular pattern", count);
            return cities;
        }

        public IReadOnlyList<City> GenerateGridCities(int rows, int cols, double spacing = 10)
        {
            _logger.LogDebug("Generating {Rows}x{Cols} cities in grid pattern (spacing: {Spacing})", rows, cols, spacing);

            var cities = new List<City>();
            var id = 0;

            for (int row = 0; row < rows; row++)
            {
                for (int col = 0; col < cols; col++)
                {
                    cities.Add(new City(
                        id,
                        $"City_{id}",
                        col * spacing,
                        row * spacing
                    ));
                    id++;
                }
            }

            _logger.LogInformation("Generated {Count} cities in {Rows}x{Cols} grid pattern", cities.Count, rows, cols);
            return cities;
        }
    }

    /// <summary>
    /// Service for comparing different TSP solvers
    /// </summary>
    public sealed class TspBenchmark
    {
        private readonly ILogger<TspBenchmark> _logger;

        public TspBenchmark(ILogger<TspBenchmark>? logger = null)
        {
            _logger = logger ?? NullLogger<TspBenchmark>.Instance;
        }

        public sealed record BenchmarkResult(
            string SolverName,
            double Distance,
            TimeSpan ExecutionTime,
            Tour Tour
        );

        public async Task<IReadOnlyList<BenchmarkResult>> RunBenchmarkAsync(
            IReadOnlyList<City> cities,
            IEnumerable<ITspSolver> solvers,
            CancellationToken cancellationToken = default)
        {
            var solverList = solvers.ToList();
            _logger.LogInformation("Starting benchmark with {CityCount} cities and {SolverCount} algorithms",
                cities.Count, solverList.Count);

            var results = new List<BenchmarkResult>();

            foreach (var solver in solverList)
            {
                cancellationToken.ThrowIfCancellationRequested();

                _logger.LogDebug("Running benchmark for {SolverName}", solver.Name);
                var startTime = DateTime.UtcNow;
                var tour = await solver.SolveAsync(cities, cancellationToken);
                var executionTime = DateTime.UtcNow - startTime;

                var result = new BenchmarkResult(solver.Name, tour.TotalDistance, executionTime, tour);
                results.Add(result);

                _logger.LogInformation("Benchmark completed for {SolverName}: Distance {Distance:F2}, Time {TimeMs}ms",
                    solver.Name, tour.TotalDistance, executionTime.TotalMilliseconds);
            }

            var sortedResults = results.OrderBy(r => r.Distance).ToList();
            _logger.LogInformation("Benchmark completed. Winner: {Winner} with distance {Distance:F2}",
                sortedResults.First().SolverName, sortedResults.First().Distance);

            return sortedResults;
        }

        public string FormatResults(IReadOnlyList<BenchmarkResult> results)
        {
            var sb = new StringBuilder();
            sb.AppendLine("\n=== TSP Solver Benchmark Results ===");
            sb.AppendLine($"{"Rank",-5} {"Solver",-20} {"Distance",-15} {"Time (ms)",-10} {"% from Best",-12}");
            sb.AppendLine(new string('-', 75));

            var bestDistance = results.First().Distance;

            for (int i = 0; i < results.Count; i++)
            {
                var result = results[i];
                var percentFromBest = ((result.Distance - bestDistance) / bestDistance) * 100;

                sb.AppendLine($"{i + 1,-5} {result.SolverName,-20} {result.Distance,-15:F2} " +
                            $"{result.ExecutionTime.TotalMilliseconds,-10:F1} {percentFromBest,-12:F2}%");
            }

            return sb.ToString();
        }
    }
}

--- C:\code\TSP\TravelingSalesman.Tests\Tests.cs ---
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Abstractions;
using TravelingSalesman.Core;
using Xunit;

namespace TravelingSalesman.Tests
{
    // ============================================================================
    // CITY TESTS
    // ============================================================================
    public class CityTests
    {
        [Fact]
        public void City_Constructor_ShouldCreateValidCity()
        {
            // Arrange & Act
            var city = new City(1, "TestCity", 10.5, 20.3);

            // Assert
            Assert.Equal(1, city.Id);
            Assert.Equal("TestCity", city.Name);
            Assert.Equal(10.5, city.X);
            Assert.Equal(20.3, city.Y);
        }

        [Fact]
        public void City_DistanceTo_ShouldCalculateCorrectEuclideanDistance()
        {
            // Arrange
            var city1 = new City(1, "City1", 0, 0);
            var city2 = new City(2, "City2", 3, 4);

            // Act
            var distance = city1.DistanceTo(city2);

            // Assert
            Assert.Equal(5.0, distance, 2); // 3-4-5 triangle
        }

        [Fact]
        public void City_DistanceTo_SameCity_ShouldReturnZero()
        {
            // Arrange
            var city = new City(1, "TestCity", 10, 20);

            // Act
            var distance = city.DistanceTo(city);

            // Assert
            Assert.Equal(0.0, distance);
        }

        [Fact]
        public void City_DistanceTo_NegativeCoordinates_ShouldWork()
        {
            // Arrange
            var city1 = new City(1, "City1", -5, -10);
            var city2 = new City(2, "City2", 5, 10);

            // Act
            var distance = city1.DistanceTo(city2);

            // Assert
            Assert.True(distance > 0);
            Assert.Equal(Math.Sqrt(400 + 400), distance, 2);
        }

        [Theory]
        [InlineData(0, 0, 1, 0, 1.0)]
        [InlineData(0, 0, 0, 1, 1.0)]
        [InlineData(1, 1, 4, 5, 5.0)]
        [InlineData(-1, -1, 2, 3, 5.0)]
        public void City_DistanceTo_VariousCoordinates_ShouldCalculateCorrectly(
            double x1, double y1, double x2, double y2, double expected)
        {
            // Arrange
            var city1 = new City(1, "City1", x1, y1);
            var city2 = new City(2, "City2", x2, y2);

            // Act
            var distance = city1.DistanceTo(city2);

            // Assert
            Assert.Equal(expected, distance, 2);
        }

        [Fact]
        public void City_Record_Equality_ShouldWorkCorrectly()
        {
            // Arrange
            var city1 = new City(1, "TestCity", 10, 20);
            var city2 = new City(1, "TestCity", 10, 20);
            var city3 = new City(2, "TestCity", 10, 20);

            // Act & Assert
            Assert.Equal(city1, city2);
            Assert.NotEqual(city1, city3);
            Assert.Equal(city1.GetHashCode(), city2.GetHashCode());
        }
    }

    // ============================================================================
    // TOUR TESTS
    // ============================================================================
    public class TourTests
    {
        private readonly List<City> _testCities;
        private readonly double[,] _distanceMatrix;

        public TourTests()
        {
            _testCities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 0),
                new City(2, "C", 1, 1),
                new City(3, "D", 0, 1)
            };

            _distanceMatrix = BuildDistanceMatrix(_testCities);
        }

        private static double[,] BuildDistanceMatrix(IReadOnlyList<City> cities)
        {
            var n = cities.Count;
            var matrix = new double[n, n];
            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < n; j++)
                {
                    matrix[i, j] = cities[i].DistanceTo(cities[j]);
                }
            }
            return matrix;
        }

        [Fact]
        public void Tour_Constructor_ShouldCreateValidTour()
        {
            // Act
            var tour = new Tour(_testCities, _distanceMatrix);

            // Assert
            Assert.NotNull(tour.Cities);
            Assert.Equal(4, tour.Cities.Count);
            Assert.Equal(_testCities[0], tour.Cities[0]);
        }

        [Fact]
        public void Tour_TotalDistance_ShouldCalculateCorrectly()
        {
            // Arrange
            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 0),
                new City(2, "C", 0, 0) // Back to origin coordinates
            };
            var matrix = BuildDistanceMatrix(cities);

            // Act
            var tour = new Tour(cities, matrix);
            var distance = tour.TotalDistance;

            // Assert
            // A->B: 1, B->C: 1, C->A: 0 = 2.0
            Assert.Equal(2.0, distance, 2);
        }

        [Fact]
        public void Tour_TotalDistance_EmptyTour_ShouldReturnZero()
        {
            // Arrange
            var emptyCities = new List<City>();
            var emptyMatrix = new double[0, 0];

            // Act
            var tour = new Tour(emptyCities, emptyMatrix);

            // Assert
            Assert.Equal(0.0, tour.TotalDistance);
        }

        [Fact]
        public void Tour_TotalDistance_SingleCity_ShouldReturnZero()
        {
            // Arrange
            var singleCity = new List<City> { new City(0, "A", 0, 0) };
            var matrix = new double[1, 1] { { 0 } };

            // Act
            var tour = new Tour(singleCity, matrix);

            // Assert
            Assert.Equal(0.0, tour.TotalDistance);
        }

        [Fact]
        public void Tour_TotalDistance_ShouldCacheResult()
        {
            // Arrange
            var tour = new Tour(_testCities, _distanceMatrix);

            // Act
            var distance1 = tour.TotalDistance;
            var distance2 = tour.TotalDistance;

            // Assert
            Assert.Equal(distance1, distance2);
            Assert.True(distance1 > 0);
        }

        [Fact]
        public void Tour_SwapCities_ShouldUpdateTour()
        {
            // Arrange
            var tour = new Tour(_testCities, _distanceMatrix);
            var originalFirst = tour.Cities[0];
            var originalSecond = tour.Cities[1];

            // Act
            tour.SwapCities(0, 1);

            // Assert
            Assert.Equal(originalSecond, tour.Cities[0]);
            Assert.Equal(originalFirst, tour.Cities[1]);
        }

        [Fact]
        public void Tour_SwapCities_SameIndex_ShouldNotChange()
        {
            // Arrange
            var tour = new Tour(_testCities, _distanceMatrix);
            var originalCities = tour.Cities.ToList();

            // Act
            tour.SwapCities(1, 1);

            // Assert
            for (int i = 0; i < originalCities.Count; i++)
            {
                Assert.Equal(originalCities[i], tour.Cities[i]);
            }
        }

        [Fact]
        public void Tour_SwapCities_ShouldInvalidateCache()
        {
            // Arrange
            var tour = new Tour(_testCities, _distanceMatrix);
            var originalDistance = tour.TotalDistance;

            // Act
            tour.SwapCities(0, 1);
            var newDistance = tour.TotalDistance;

            // Assert - distance might change depending on tour
            Assert.True(originalDistance >= 0);
            Assert.True(newDistance >= 0);
        }

        [Fact]
        public void Tour_Reverse_ShouldReverseSegment()
        {
            // Arrange
            var cities = _testCities.ToList(); // A, B, C, D
            var tour = new Tour(cities, _distanceMatrix);

            // Act
            tour.Reverse(1, 2); // Reverse B, C

            // Assert
            Assert.Equal("A", tour.Cities[0].Name);
            Assert.Equal("C", tour.Cities[1].Name);
            Assert.Equal("B", tour.Cities[2].Name);
            Assert.Equal("D", tour.Cities[3].Name);
        }

        [Fact]
        public void Tour_Reverse_WholeRange_ShouldReverseAll()
        {
            // Arrange
            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 0),
                new City(2, "C", 2, 0)
            };
            var matrix = BuildDistanceMatrix(cities);
            var tour = new Tour(cities, matrix);

            // Act
            tour.Reverse(0, 2);

            // Assert
            Assert.Equal("C", tour.Cities[0].Name);
            Assert.Equal("B", tour.Cities[1].Name);
            Assert.Equal("A", tour.Cities[2].Name);
        }

        [Fact]
        public void Tour_Clone_ShouldCreateIndependentCopy()
        {
            // Arrange
            var tour = new Tour(_testCities, _distanceMatrix);

            // Act
            var cloned = tour.Clone();

            // Assert
            Assert.NotSame(tour, cloned);
            Assert.Equal(tour.TotalDistance, cloned.TotalDistance);
            Assert.Equal(tour.Cities.Count, cloned.Cities.Count);
        }

        [Fact]
        public void Tour_ToString_ShouldReturnFormattedString()
        {
            // Arrange
            var tour = new Tour(_testCities, _distanceMatrix);

            // Act
            var result = tour.ToString();

            // Assert
            Assert.Contains("Tour Distance:", result);
            Assert.Contains("Route:", result);
            Assert.Contains("A", result);
        }
    }

    // ============================================================================
    // TSP SOLVER BASE TESTS
    // ============================================================================
    public class TspSolverBaseTests
    {
        private class TestSolver : TspSolverBase
        {
            public override string Name => "Test Solver";

            public TestSolver(ILogger? logger = null) : base(logger) { }

            public override Task<Tour> SolveAsync(IReadOnlyList<City> cities, CancellationToken cancellationToken = default)
            {
                var distanceMatrix = BuildDistanceMatrix(cities);
                OnProgressChanged(1, 100.0, "Test progress");
                return Task.FromResult(new Tour(cities, distanceMatrix));
            }

            public double[,] TestBuildDistanceMatrix(IReadOnlyList<City> cities) => BuildDistanceMatrix(cities);
            public void TestOnProgressChanged(int iteration, double distance, string message) =>
                OnProgressChanged(iteration, distance, message);
        }

        [Fact]
        public void TspSolverBase_BuildDistanceMatrix_ShouldCreateCorrectMatrix()
        {
            // Arrange
            var solver = new TestSolver();
            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 0),
                new City(2, "C", 0, 1)
            };

            // Act
            var matrix = solver.TestBuildDistanceMatrix(cities);

            // Assert
            Assert.Equal(3, matrix.GetLength(0));
            Assert.Equal(3, matrix.GetLength(1));
            Assert.Equal(0.0, matrix[0, 0]);
            Assert.Equal(1.0, matrix[0, 1], 2);
            Assert.Equal(1.0, matrix[0, 2], 2);
        }

        [Fact]
        public void TspSolverBase_ProgressChanged_ShouldRaiseEvent()
        {
            // Arrange
            var solver = new TestSolver();
            var eventRaised = false;
            TspProgressEventArgs? eventArgs = null;

            solver.ProgressChanged += (sender, args) =>
            {
                eventRaised = true;
                eventArgs = args;
            };

            // Act
            solver.TestOnProgressChanged(5, 123.45, "Test message");

            // Assert
            Assert.True(eventRaised);
            Assert.NotNull(eventArgs);
            Assert.Equal(5, eventArgs.Iteration);
            Assert.Equal(123.45, eventArgs.CurrentBestDistance);
            Assert.Equal("Test message", eventArgs.Message);
        }

        [Fact]
        public async Task TspSolverBase_SolveAsync_ShouldReturnValidTour()
        {
            // Arrange
            var solver = new TestSolver();
            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 0)
            };

            // Act
            var tour = await solver.SolveAsync(cities);

            // Assert
            Assert.NotNull(tour);
            Assert.Equal(2, tour.Cities.Count);
        }
    }

    // ============================================================================
    // NEAREST NEIGHBOR SOLVER TESTS
    // ============================================================================
    public class NearestNeighborSolverTests
    {
        [Fact]
        public void NearestNeighborSolver_Name_ShouldReturnCorrectName()
        {
            // Arrange
            var solver = new NearestNeighborSolver();

            // Assert
            Assert.Equal("Nearest Neighbor", solver.Name);
        }

        [Fact]
        public async Task NearestNeighborSolver_SolveAsync_EmptyList_ShouldReturnEmptyTour()
        {
            // Arrange
            var solver = new NearestNeighborSolver();
            var cities = new List<City>();

            // Act
            var tour = await solver.SolveAsync(cities);

            // Assert
            Assert.NotNull(tour);
            Assert.Empty(tour.Cities);
            Assert.Equal(0.0, tour.TotalDistance);
        }

        [Fact]
        public async Task NearestNeighborSolver_SolveAsync_SingleCity_ShouldReturnSingleCityTour()
        {
            // Arrange
            var solver = new NearestNeighborSolver();
            var cities = new List<City> { new City(0, "A", 0, 0) };

            // Act
            var tour = await solver.SolveAsync(cities);

            // Assert
            Assert.NotNull(tour);
            Assert.Single(tour.Cities);
            Assert.Equal(0.0, tour.TotalDistance);
        }

        [Fact]
        public async Task NearestNeighborSolver_SolveAsync_TwoCities_ShouldReturnValidTour()
        {
            // Arrange
            var solver = new NearestNeighborSolver();
            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 0)
            };

            // Act
            var tour = await solver.SolveAsync(cities);

            // Assert
            Assert.NotNull(tour);
            Assert.Equal(2, tour.Cities.Count);
            Assert.Equal("A", tour.Cities[0].Name);
            Assert.Equal("B", tour.Cities[1].Name);
            Assert.Equal(2.0, tour.TotalDistance); // A->B->A = 1+1 = 2
        }

        [Fact]
        public async Task NearestNeighborSolver_SolveAsync_MultipleCities_ShouldStartFromFirstCity()
        {
            // Arrange
            var solver = new NearestNeighborSolver();
            var cities = new List<City>
            {
                new City(0, "Start", 0, 0),
                new City(1, "B", 10, 0),
                new City(2, "C", 1, 0),  // Nearest to Start
                new City(3, "D", 5, 0)
            };

            // Act
            var tour = await solver.SolveAsync(cities);

            // Assert
            Assert.Equal("Start", tour.Cities[0].Name);
            Assert.Equal("C", tour.Cities[1].Name); // Should pick nearest (C) next
        }

        [Fact]
        public async Task NearestNeighborSolver_SolveAsync_ShouldRaiseProgressEvents()
        {
            // Arrange
            var solver = new NearestNeighborSolver();
            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 0),
                new City(2, "C", 2, 0)
            };

            var progressEvents = new List<TspProgressEventArgs>();
            solver.ProgressChanged += (sender, args) => progressEvents.Add(args);

            // Act
            await solver.SolveAsync(cities);

            // Assert
            Assert.True(progressEvents.Count > 0);
            Assert.All(progressEvents, e => Assert.True(e.Iteration > 0));
        }

        [Fact]
        public async Task NearestNeighborSolver_SolveAsync_Cancellation_ShouldThrow()
        {
            // Arrange
            var solver = new NearestNeighborSolver();
            var cities = Enumerable.Range(0, 100)
                .Select(i => new City(i, $"City{i}", i * 10, i * 5))
                .ToList();

            using var cts = new CancellationTokenSource();
            cts.Cancel();

            // Act & Assert
            await Assert.ThrowsAsync<OperationCanceledException>(
                () => solver.SolveAsync(cities, cts.Token));
        }

        [Fact]
        public async Task NearestNeighborSolver_SolveAsync_DeterministicResults()
        {
            // Arrange
            var solver = new NearestNeighborSolver();
            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 1),
                new City(2, "C", 2, 0),
                new City(3, "D", 1, -1)
            };

            // Act
            var tour1 = await solver.SolveAsync(cities);
            var tour2 = await solver.SolveAsync(cities);

            // Assert
            Assert.Equal(tour1.TotalDistance, tour2.TotalDistance);
            Assert.Equal(tour1.Cities.Count, tour2.Cities.Count);
            for (int i = 0; i < tour1.Cities.Count; i++)
            {
                Assert.Equal(tour1.Cities[i].Id, tour2.Cities[i].Id);
            }
        }
    }

    // ============================================================================
    // TWO-OPT SOLVER TESTS
    // ============================================================================
    public class TwoOptSolverTests
    {
        [Fact]
        public void TwoOptSolver_Name_ShouldReturnCorrectName()
        {
            // Arrange
            var solver = new TwoOptSolver();

            // Assert
            Assert.Equal("2-Opt", solver.Name);
        }

        [Fact]
        public void TwoOptSolver_Constructor_ShouldAcceptMaxIterations()
        {
            // Act
            var solver = new TwoOptSolver(maxIterations: 500);

            // Assert
            Assert.Equal("2-Opt", solver.Name);
        }

        [Fact]
        public async Task TwoOptSolver_SolveAsync_ShouldImproveInitialSolution()
        {
            // Arrange
            var solver = new TwoOptSolver(maxIterations: 10);

            // Create a deliberately suboptimal tour (crossing paths)
            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 1),
                new City(2, "C", 0, 1),
                new City(3, "D", 1, 0)
            };

            // Act
            var tour = await solver.SolveAsync(cities);

            // Assert
            Assert.NotNull(tour);
            Assert.Equal(4, tour.Cities.Count);
            Assert.True(tour.TotalDistance > 0);
        }

        [Fact]
        public async Task TwoOptSolver_SolveAsync_SmallTour_ShouldComplete()
        {
            // Arrange
            var solver = new TwoOptSolver();
            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 0)
            };

            // Act
            var tour = await solver.SolveAsync(cities);

            // Assert
            Assert.NotNull(tour);
            Assert.Equal(2, tour.Cities.Count);
        }

        [Fact]
        public async Task TwoOptSolver_SolveAsync_ShouldRaiseProgressEvents()
        {
            // Arrange
            var solver = new TwoOptSolver(maxIterations: 5);
            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 0),
                new City(2, "C", 1, 1),
                new City(3, "D", 0, 1)
            };

            var progressEvents = new List<TspProgressEventArgs>();
            solver.ProgressChanged += (sender, args) => progressEvents.Add(args);

            // Act
            await solver.SolveAsync(cities);

            // Assert
            // Should have events from both NN and 2-opt phases
            Assert.True(progressEvents.Count > 0);
        }

        [Fact]
        public async Task TwoOptSolver_SolveAsync_Cancellation_ShouldThrow()
        {
            // Arrange
            var solver = new TwoOptSolver(maxIterations: 10000);
            var cities = Enumerable.Range(0, 50)
                .Select(i => new City(i, $"City{i}", i, i))
                .ToList();

            using var cts = new CancellationTokenSource();
            cts.Cancel();

            // Act & Assert
            await Assert.ThrowsAsync<OperationCanceledException>(
                () => solver.SolveAsync(cities, cts.Token));
        }

        [Theory]
        [InlineData(1)]
        [InlineData(10)]
        [InlineData(100)]
        public async Task TwoOptSolver_SolveAsync_DifferentMaxIterations_ShouldWork(int maxIterations)
        {
            // Arrange
            var solver = new TwoOptSolver(maxIterations: maxIterations);
            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 2, 0),
                new City(2, "C", 2, 2),
                new City(3, "D", 0, 2)
            };

            // Act
            var tour = await solver.SolveAsync(cities);

            // Assert
            Assert.NotNull(tour);
            Assert.Equal(4, tour.Cities.Count);
            Assert.True(tour.TotalDistance > 0);
        }
    }

    // ============================================================================
    // SIMULATED ANNEALING SOLVER TESTS
    // ============================================================================
    public class SimulatedAnnealingSolverTests
    {
        [Fact]
        public void SimulatedAnnealingSolver_Name_ShouldReturnCorrectName()
        {
            // Arrange
            var solver = new SimulatedAnnealingSolver();

            // Assert
            Assert.Equal("Simulated Annealing", solver.Name);
        }

        [Fact]
        public void SimulatedAnnealingSolver_Constructor_DefaultParameters_ShouldWork()
        {
            // Act
            var solver = new SimulatedAnnealingSolver();

            // Assert
            Assert.Equal("Simulated Annealing", solver.Name);
        }

        [Fact]
        public void SimulatedAnnealingSolver_Constructor_CustomParameters_ShouldWork()
        {
            // Act
            var solver = new SimulatedAnnealingSolver(
                initialTemperature: 5000,
                coolingRate: 0.95,
                iterationsPerTemperature: 50);

            // Assert
            Assert.Equal("Simulated Annealing", solver.Name);
        }

        [Fact]
        public async Task SimulatedAnnealingSolver_SolveAsync_ShouldReturnValidTour()
        {
            // Arrange
            var solver = new SimulatedAnnealingSolver(
                initialTemperature: 100,
                coolingRate: 0.9,
                iterationsPerTemperature: 10);

            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 0),
                new City(2, "C", 1, 1),
                new City(3, "D", 0, 1)
            };

            // Act
            var tour = await solver.SolveAsync(cities);

            // Assert
            Assert.NotNull(tour);
            Assert.Equal(4, tour.Cities.Count);
            Assert.True(tour.TotalDistance > 0);
        }

        [Fact]
        public async Task SimulatedAnnealingSolver_SolveAsync_WithSeed_ShouldBeDeterministic()
        {
            // Arrange
            const int seed = 12345;
            var solver1 = new SimulatedAnnealingSolver(
                initialTemperature: 100,
                coolingRate: 0.8,
                iterationsPerTemperature: 5,
                seed: seed);

            var solver2 = new SimulatedAnnealingSolver(
                initialTemperature: 100,
                coolingRate: 0.8,
                iterationsPerTemperature: 5,
                seed: seed);

            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 2, 0),
                new City(2, "C", 1, 1)
            };

            // Act
            var tour1 = await solver1.SolveAsync(cities);
            var tour2 = await solver2.SolveAsync(cities);

            // Assert
            Assert.Equal(tour1.TotalDistance, tour2.TotalDistance);
        }

        [Fact]
        public async Task SimulatedAnnealingSolver_SolveAsync_ShouldRaiseProgressEvents()
        {
            // Arrange
            var solver = new SimulatedAnnealingSolver(
                initialTemperature: 100,
                coolingRate: 0.5,
                iterationsPerTemperature: 5);

            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 0),
                new City(2, "C", 1, 1)
            };

            var progressEvents = new List<TspProgressEventArgs>();
            solver.ProgressChanged += (sender, args) => progressEvents.Add(args);

            // Act
            await solver.SolveAsync(cities);

            // Assert
            Assert.True(progressEvents.Count > 0);
        }

        [Fact]
        public async Task SimulatedAnnealingSolver_SolveAsync_TwoCities_ShouldWork()
        {
            // Arrange
            var solver = new SimulatedAnnealingSolver(
                initialTemperature: 10,
                coolingRate: 0.5,
                iterationsPerTemperature: 2);

            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 0)
            };

            // Act
            var tour = await solver.SolveAsync(cities);

            // Assert
            Assert.NotNull(tour);
            Assert.Equal(2, tour.Cities.Count);
            Assert.Equal(2.0, tour.TotalDistance); // A->B->A
        }

        [Fact]
        public async Task SimulatedAnnealingSolver_SolveAsync_Cancellation_ShouldThrow()
        {
            // Arrange
            var solver = new SimulatedAnnealingSolver(
                initialTemperature: 10000,
                coolingRate: 0.9999,
                iterationsPerTemperature: 1000);

            var cities = Enumerable.Range(0, 20)
                .Select(i => new City(i, $"City{i}", i, i))
                .ToList();

            using var cts = new CancellationTokenSource();
            cts.Cancel();

            // Act & Assert
            await Assert.ThrowsAsync<OperationCanceledException>(
                () => solver.SolveAsync(cities, cts.Token));
        }
    }

    // ============================================================================
    // GENETIC ALGORITHM SOLVER TESTS
    // ============================================================================
    public class GeneticAlgorithmSolverTests
    {
        [Fact]
        public void GeneticAlgorithmSolver_Name_ShouldReturnCorrectName()
        {
            // Arrange
            var solver = new GeneticAlgorithmSolver();

            // Assert
            Assert.Equal("Genetic Algorithm", solver.Name);
        }

        [Fact]
        public void GeneticAlgorithmSolver_Constructor_DefaultParameters_ShouldWork()
        {
            // Act
            var solver = new GeneticAlgorithmSolver();

            // Assert
            Assert.Equal("Genetic Algorithm", solver.Name);
        }

        [Fact]
        public void GeneticAlgorithmSolver_Constructor_CustomParameters_ShouldWork()
        {
            // Act
            var solver = new GeneticAlgorithmSolver(
                populationSize: 50,
                generations: 100,
                mutationRate: 0.05,
                elitismRate: 0.1);

            // Assert
            Assert.Equal("Genetic Algorithm", solver.Name);
        }

        [Fact]
        public void GeneticAlgorithmSolver_CreateScaledGeneticSolver_ShouldCreateWithScaledParameters()
        {
            // Act
            var solver = GeneticAlgorithmSolver.CreateScaledGeneticSolver(50);

            // Assert
            Assert.Equal("Genetic Algorithm", solver.Name);
        }

        [Fact]
        public async Task GeneticAlgorithmSolver_SolveAsync_ShouldReturnValidTour()
        {
            // Arrange
            var solver = new GeneticAlgorithmSolver(
                populationSize: 20,
                generations: 10,
                mutationRate: 0.1,
                elitismRate: 0.2);

            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 0),
                new City(2, "C", 1, 1),
                new City(3, "D", 0, 1)
            };

            // Act
            var tour = await solver.SolveAsync(cities);

            // Assert
            Assert.NotNull(tour);
            Assert.Equal(4, tour.Cities.Count);
            Assert.True(tour.TotalDistance > 0);
            Assert.Equal("A", tour.Cities[0].Name); // Should keep first city fixed
        }

        [Fact]
        public async Task GeneticAlgorithmSolver_SolveAsync_WithSeed_ShouldBeDeterministic()
        {
            // Arrange
            const int seed = 54321;
            var solver1 = new GeneticAlgorithmSolver(
                populationSize: 10,
                generations: 5,
                mutationRate: 0.1,
                elitismRate: 0.1,
                seed: seed);

            var solver2 = new GeneticAlgorithmSolver(
                populationSize: 10,
                generations: 5,
                mutationRate: 0.1,
                elitismRate: 0.1,
                seed: seed);

            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 0),
                new City(2, "C", 1, 1)
            };

            // Act
            var tour1 = await solver1.SolveAsync(cities);
            var tour2 = await solver2.SolveAsync(cities);

            // Assert
            Assert.Equal(tour1.TotalDistance, tour2.TotalDistance);
        }

        [Fact]
        public async Task GeneticAlgorithmSolver_SolveAsync_ShouldRaiseProgressEvents()
        {
            // Arrange
            var solver = new GeneticAlgorithmSolver(
                populationSize: 10,
                generations: 5,
                mutationRate: 0.1,
                elitismRate: 0.2);

            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 0),
                new City(2, "C", 0, 1)
            };

            var progressEvents = new List<TspProgressEventArgs>();
            solver.ProgressChanged += (sender, args) => progressEvents.Add(args);

            // Act
            await solver.SolveAsync(cities);

            // Assert
            Assert.True(progressEvents.Count > 0);
        }

        [Fact]
        public async Task GeneticAlgorithmSolver_SolveAsync_TwoCities_ShouldWork()
        {
            // Arrange
            var solver = new GeneticAlgorithmSolver(
                populationSize: 5,
                generations: 2);

            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 0)
            };

            // Act
            var tour = await solver.SolveAsync(cities);

            // Assert
            Assert.NotNull(tour);
            Assert.Equal(2, tour.Cities.Count);
            Assert.Equal(2.0, tour.TotalDistance);
        }

        [Fact]
        public async Task GeneticAlgorithmSolver_SolveAsync_Cancellation_ShouldThrow()
        {
            // Arrange
            var solver = new GeneticAlgorithmSolver(
                populationSize: 100,
                generations: 1000);

            var cities = Enumerable.Range(0, 30)
                .Select(i => new City(i, $"City{i}", i, i * 2))
                .ToList();

            using var cts = new CancellationTokenSource();
            cts.Cancel();

            // Act & Assert
            await Assert.ThrowsAsync<OperationCanceledException>(
                () => solver.SolveAsync(cities, cts.Token));
        }

        [Theory]
        [InlineData(0.0, 0.1)] // No mutation, some elitism
        [InlineData(0.1, 0.0)] // Some mutation, no elitism
        [InlineData(0.2, 0.3)] // Both mutation and elitism
        public async Task GeneticAlgorithmSolver_SolveAsync_DifferentRates_ShouldWork(
            double mutationRate, double elitismRate)
        {
            // Arrange
            var solver = new GeneticAlgorithmSolver(
                populationSize: 10,
                generations: 3,
                mutationRate: mutationRate,
                elitismRate: elitismRate);

            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 0),
                new City(2, "C", 0, 1)
            };

            // Act
            var tour = await solver.SolveAsync(cities);

            // Assert
            Assert.NotNull(tour);
            Assert.Equal(3, tour.Cities.Count);
        }
    }

    // ============================================================================
    // TSP SOLVER FACTORY TESTS
    // ============================================================================
    public class TspSolverFactoryTests
    {
        [Theory]
        [InlineData(TspSolverFactory.SolverType.NearestNeighbor, "Nearest Neighbor")]
        [InlineData(TspSolverFactory.SolverType.TwoOpt, "2-Opt")]
        [InlineData(TspSolverFactory.SolverType.SimulatedAnnealing, "Simulated Annealing")]
        [InlineData(TspSolverFactory.SolverType.GeneticAlgorithm, "Genetic Algorithm")]
        public void TspSolverFactory_CreateSolver_ShouldReturnCorrectSolverType(
            TspSolverFactory.SolverType solverType, string expectedName)
        {
            // Act
            var solver = TspSolverFactory.CreateSolver(solverType);

            // Assert
            Assert.Equal(expectedName, solver.Name);
        }

        [Fact]
        public void TspSolverFactory_CreateSolver_InvalidType_ShouldThrow()
        {
            // Act & Assert
            Assert.Throws<ArgumentException>(() =>
                TspSolverFactory.CreateSolver((TspSolverFactory.SolverType)999));
        }

        [Fact]
        public void TspSolverFactory_CreateAllSolvers_ShouldReturnAllTypes()
        {
            // Act
            var solvers = TspSolverFactory.CreateAllSolvers().ToList();

            // Assert
            Assert.Equal(4, solvers.Count);
            Assert.Contains(solvers, s => s.Name == "Nearest Neighbor");
            Assert.Contains(solvers, s => s.Name == "2-Opt");
            Assert.Contains(solvers, s => s.Name == "Simulated Annealing");
            Assert.Contains(solvers, s => s.Name == "Genetic Algorithm");
        }

        [Fact]
        public void TspSolverFactory_CreateSolver_WithLoggerFactory_ShouldWork()
        {
            // Arrange
            using var loggerFactory = LoggerFactory.Create(builder => { });

            // Act
            var solver = TspSolverFactory.CreateSolver(
                TspSolverFactory.SolverType.NearestNeighbor, loggerFactory);

            // Assert
            Assert.Equal("Nearest Neighbor", solver.Name);
        }

        [Fact]
        public void TspSolverFactory_CreateAllSolvers_WithLoggerFactory_ShouldWork()
        {
            // Arrange
            using var loggerFactory = LoggerFactory.Create(builder => { });

            // Act
            var solvers = TspSolverFactory.CreateAllSolvers(loggerFactory).ToList();

            // Assert
            Assert.Equal(4, solvers.Count);
        }
    }

    // ============================================================================
    // TSP DATA GENERATOR TESTS
    // ============================================================================
    public class TspDataGeneratorTests
    {
        [Fact]
        public void TspDataGenerator_Constructor_ShouldWork()
        {
            // Act
            var generator = new TspDataGenerator();

            // Assert
            Assert.NotNull(generator);
        }

        [Fact]
        public void TspDataGenerator_Constructor_WithSeed_ShouldWork()
        {
            // Act
            var generator = new TspDataGenerator(seed: 12345);

            // Assert
            Assert.NotNull(generator);
        }

        [Theory]
        [InlineData(1)]
        [InlineData(5)]
        [InlineData(50)]
        public void TspDataGenerator_GenerateRandomCities_ShouldGenerateCorrectCount(int count)
        {
            // Arrange
            var generator = new TspDataGenerator(seed: 123);

            // Act
            var cities = generator.GenerateRandomCities(count);

            // Assert
            Assert.Equal(count, cities.Count);
            Assert.All(cities, city =>
            {
                Assert.True(city.X >= 0 && city.X <= 100);
                Assert.True(city.Y >= 0 && city.Y <= 100);
                Assert.False(string.IsNullOrEmpty(city.Name));
            });
        }

        [Fact]
        public void TspDataGenerator_GenerateRandomCities_WithSeed_ShouldBeDeterministic()
        {
            // Arrange
            const int seed = 456;
            var generator1 = new TspDataGenerator(seed);
            var generator2 = new TspDataGenerator(seed);

            // Act
            var cities1 = generator1.GenerateRandomCities(10);
            var cities2 = generator2.GenerateRandomCities(10);

            // Assert
            Assert.Equal(cities1.Count, cities2.Count);
            for (int i = 0; i < cities1.Count; i++)
            {
                Assert.Equal(cities1[i].X, cities2[i].X);
                Assert.Equal(cities1[i].Y, cities2[i].Y);
                Assert.Equal(cities1[i].Name, cities2[i].Name);
            }
        }

        [Fact]
        public void TspDataGenerator_GenerateRandomCities_CustomBounds_ShouldRespectBounds()
        {
            // Arrange
            var generator = new TspDataGenerator(seed: 789);

            // Act
            var cities = generator.GenerateRandomCities(20, maxX: 50, maxY: 30);

            // Assert
            Assert.All(cities, city =>
            {
                Assert.True(city.X >= 0 && city.X <= 50);
                Assert.True(city.Y >= 0 && city.Y <= 30);
            });
        }

        [Theory]
        [InlineData(3)]
        [InlineData(8)]
        [InlineData(16)]
        public void TspDataGenerator_GenerateCircularCities_ShouldGenerateCircularPattern(int count)
        {
            // Arrange
            var generator = new TspDataGenerator(seed: 321);

            // Act
            var cities = generator.GenerateCircularCities(count, radius: 10);

            // Assert
            Assert.Equal(count, cities.Count);

            // Check that cities are roughly on a circle (allow some floating point tolerance)
            const double centerX = 50;
            const double centerY = 50;
            const double radius = 10;

            Assert.All(cities, city =>
            {
                var distance = Math.Sqrt(Math.Pow(city.X - centerX, 2) + Math.Pow(city.Y - centerY, 2));
                Assert.Equal(radius, distance, 1); // 1 unit tolerance
            });
        }

        [Fact]
        public void TspDataGenerator_GenerateCircularCities_CustomParameters_ShouldWork()
        {
            // Arrange
            var generator = new TspDataGenerator();

            // Act
            var cities = generator.GenerateCircularCities(6, radius: 25, centerX: 30, centerY: 40);

            // Assert
            Assert.Equal(6, cities.Count);
            Assert.All(cities, city =>
            {
                var distance = Math.Sqrt(Math.Pow(city.X - 30, 2) + Math.Pow(city.Y - 40, 2));
                Assert.Equal(25, distance, 1);
            });
        }

        [Theory]
        [InlineData(2, 3)] // 2x3 grid
        [InlineData(4, 4)] // 4x4 grid
        [InlineData(1, 5)] // 1x5 grid
        public void TspDataGenerator_GenerateGridCities_ShouldGenerateGridPattern(int rows, int cols)
        {
            // Arrange
            var generator = new TspDataGenerator();

            // Act
            var cities = generator.GenerateGridCities(rows, cols);

            // Assert
            Assert.Equal(rows * cols, cities.Count);

            // Verify grid structure
            var cityArray = cities.ToArray();
            for (int row = 0; row < rows; row++)
            {
                for (int col = 0; col < cols; col++)
                {
                    var city = cityArray[row * cols + col];
                    Assert.Equal(col * 10.0, city.X); // Default spacing is 10
                    Assert.Equal(row * 10.0, city.Y);
                }
            }
        }

        [Fact]
        public void TspDataGenerator_GenerateGridCities_CustomSpacing_ShouldWork()
        {
            // Arrange
            var generator = new TspDataGenerator();

            // Act
            var cities = generator.GenerateGridCities(2, 2, spacing: 5);

            // Assert
            Assert.Equal(4, cities.Count);
            Assert.Equal(0, cities[0].X);
            Assert.Equal(0, cities[0].Y);
            Assert.Equal(5, cities[1].X);
            Assert.Equal(0, cities[1].Y);
            Assert.Equal(0, cities[2].X);
            Assert.Equal(5, cities[2].Y);
            Assert.Equal(5, cities[3].X);
            Assert.Equal(5, cities[3].Y);
        }

        [Fact]
        public void TspDataGenerator_AllMethods_ShouldGenerateUniqueIds()
        {
            // Arrange
            var generator = new TspDataGenerator(seed: 111);

            // Act
            var randomCities = generator.GenerateRandomCities(5);
            var circularCities = generator.GenerateCircularCities(5);
            var gridCities = generator.GenerateGridCities(2, 3);

            // Assert
            var allGeneratedCities = new[] { randomCities, circularCities, gridCities };

            foreach (var cityList in allGeneratedCities)
            {
                var ids = cityList.Select(c => c.Id).ToList();
                var uniqueIds = ids.Distinct().ToList();
                Assert.Equal(ids.Count, uniqueIds.Count); // All IDs should be unique
                Assert.Equal(0, ids.Min()); // IDs should start from 0
                Assert.Equal(ids.Count - 1, ids.Max()); // IDs should be sequential
            }
        }

        [Fact]
        public void TspDataGenerator_GeneratedCities_ShouldHaveValidNames()
        {
            // Arrange
            var generator = new TspDataGenerator();

            // Act
            var cities = generator.GenerateRandomCities(5);

            // Assert
            Assert.All(cities, city =>
            {
                Assert.False(string.IsNullOrWhiteSpace(city.Name));
                Assert.StartsWith("City_", city.Name);
            });
        }
    }

    // ============================================================================
    // TSP BENCHMARK TESTS
    // ============================================================================
    public class TspBenchmarkTests
    {
        [Fact]
        public void TspBenchmark_Constructor_ShouldWork()
        {
            // Act
            var benchmark = new TspBenchmark();

            // Assert
            Assert.NotNull(benchmark);
        }

        [Fact]
        public async Task TspBenchmark_RunBenchmarkAsync_ShouldReturnResults()
        {
            // Arrange
            var benchmark = new TspBenchmark();
            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 0),
                new City(2, "C", 1, 1)
            };

            var solvers = new List<ITspSolver>
            {
                new NearestNeighborSolver(),
                new TwoOptSolver(maxIterations: 5)
            };

            // Act
            var results = await benchmark.RunBenchmarkAsync(cities, solvers);

            // Assert
            Assert.Equal(2, results.Count);
            Assert.All(results, result =>
            {
                Assert.NotNull(result.SolverName);
                Assert.True(result.Distance > 0);
                Assert.True(result.ExecutionTime.TotalMilliseconds >= 0);
                Assert.NotNull(result.Tour);
            });
        }

        [Fact]
        public async Task TspBenchmark_RunBenchmarkAsync_ShouldSortResultsByDistance()
        {
            // Arrange
            var benchmark = new TspBenchmark();
            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 2, 0),
                new City(2, "C", 1, 1),
                new City(3, "D", 0, 1)
            };

            var solvers = new List<ITspSolver>
            {
                new NearestNeighborSolver(),
                new TwoOptSolver(maxIterations: 2),
                new SimulatedAnnealingSolver(100, 0.5, 5)
            };

            // Act
            var results = await benchmark.RunBenchmarkAsync(cities, solvers);

            // Assert
            for (int i = 1; i < results.Count; i++)
            {
                Assert.True(results[i].Distance >= results[i - 1].Distance);
            }
        }

        [Fact]
        public async Task TspBenchmark_RunBenchmarkAsync_EmptySolvers_ShouldReturnEmpty()
        {
            // Arrange
            var benchmark = new TspBenchmark();
            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 0)
            };

            var solvers = new List<ITspSolver>();

            // Act
            var results = await benchmark.RunBenchmarkAsync(cities, solvers);

            // Assert
            Assert.Empty(results);
        }

        [Fact]
        public async Task TspBenchmark_RunBenchmarkAsync_Cancellation_ShouldThrow()
        {
            // Arrange
            var benchmark = new TspBenchmark();
            var cities = Enumerable.Range(0, 20)
                .Select(i => new City(i, $"City{i}", i, i))
                .ToList();

            var solvers = new List<ITspSolver>
            {
                new GeneticAlgorithmSolver(100, 1000, 0.1, 0.1)
            };

            using var cts = new CancellationTokenSource();
            cts.Cancel();

            // Act & Assert
            await Assert.ThrowsAsync<OperationCanceledException>(
                () => benchmark.RunBenchmarkAsync(cities, solvers, cts.Token));
        }

        [Fact]
        public void TspBenchmark_FormatResults_ShouldReturnFormattedString()
        {
            // Arrange
            var benchmark = new TspBenchmark();
            var results = new List<TspBenchmark.BenchmarkResult>
            {
                new("Solver A", 100.0, TimeSpan.FromMilliseconds(50),
                    new Tour(new List<City>(), new double[0,0])),
                new("Solver B", 120.0, TimeSpan.FromMilliseconds(75),
                    new Tour(new List<City>(), new double[0,0]))
            };

            // Act
            var formatted = benchmark.FormatResults(results);

            // Assert
            Assert.Contains("TSP Solver Benchmark Results", formatted);
            Assert.Contains("Solver A", formatted);
            Assert.Contains("Solver B", formatted);
            Assert.Contains("100.00", formatted);
            Assert.Contains("120.00", formatted);
            Assert.Contains("50.0", formatted);
            Assert.Contains("75.0", formatted);
            Assert.Contains("0.00%", formatted); // Best is 0% from itself
            Assert.Contains("20.00%", formatted); // 120 is 20% more than 100
        }

        [Fact]
        public void TspBenchmark_BenchmarkResult_Record_ShouldWorkCorrectly()
        {
            // Arrange
            var cities = new List<City> { new City(0, "A", 0, 0) };
            var tour = new Tour(cities, new double[1,1]);

            // Act
            var result = new TspBenchmark.BenchmarkResult(
                "Test Solver",
                50.5,
                TimeSpan.FromMilliseconds(100),
                tour);

            // Assert
            Assert.Equal("Test Solver", result.SolverName);
            Assert.Equal(50.5, result.Distance);
            Assert.Equal(100, result.ExecutionTime.TotalMilliseconds);
            Assert.Equal(tour, result.Tour);
        }
    }

    // ============================================================================
    // TSP PROGRESS EVENT ARGS TESTS
    // ============================================================================
    public class TspProgressEventArgsTests
    {
        [Fact]
        public void TspProgressEventArgs_Properties_ShouldSetCorrectly()
        {
            // Act
            var args = new TspProgressEventArgs
            {
                Iteration = 42,
                CurrentBestDistance = 123.45,
                Message = "Test message"
            };

            // Assert
            Assert.Equal(42, args.Iteration);
            Assert.Equal(123.45, args.CurrentBestDistance);
            Assert.Equal("Test message", args.Message);
        }

        [Fact]
        public void TspProgressEventArgs_DefaultMessage_ShouldBeEmpty()
        {
            // Act
            var args = new TspProgressEventArgs
            {
                Iteration = 1,
                CurrentBestDistance = 100.0
            };

            // Assert
            Assert.Equal(string.Empty, args.Message);
        }

        [Fact]
        public void TspProgressEventArgs_InheritsFromEventArgs()
        {
            // Arrange & Act
            var args = new TspProgressEventArgs();

            // Assert
            Assert.IsAssignableFrom<EventArgs>(args);
        }
    }

    // ============================================================================
    // INTEGRATION TESTS
    // ============================================================================
    public class IntegrationTests
    {
        [Fact]
        public async Task Integration_AllSolvers_SameCities_ShouldProduceDifferentResults()
        {
            // Arrange
            var generator = new TspDataGenerator(seed: 12345);
            var cities = generator.GenerateRandomCities(8);

            var solvers = TspSolverFactory.CreateAllSolvers().ToList();

            // Act
            var tasks = solvers.Select(solver => solver.SolveAsync(cities)).ToList();
            var tours = await Task.WhenAll(tasks);

            // Assert
            Assert.Equal(4, tours.Length);
            Assert.All(tours, tour =>
            {
                Assert.Equal(cities.Count, tour.Cities.Count);
                Assert.True(tour.TotalDistance > 0);
            });

            // At least some should have different distances (though not guaranteed)
            var distances = tours.Select(t => Math.Round(t.TotalDistance, 2)).Distinct().ToList();
            // We can't guarantee they'll all be different, but we can check they're all valid
            Assert.All(distances, d => Assert.True(d > 0));
        }

        [Fact]
        public async Task Integration_Benchmark_WithAllSolvers_ShouldComplete()
        {
            // Arrange
            var generator = new TspDataGenerator(seed: 999);
            var cities = generator.GenerateCircularCities(6);
            var benchmark = new TspBenchmark();

            var solvers = new List<ITspSolver>
            {
                new NearestNeighborSolver(),
                new TwoOptSolver(maxIterations: 10),
                new SimulatedAnnealingSolver(100, 0.8, 5),
                new GeneticAlgorithmSolver(10, 5, 0.1, 0.2)
            };

            // Act
            var results = await benchmark.RunBenchmarkAsync(cities, solvers);
            var formatted = benchmark.FormatResults(results);

            // Assert
            Assert.Equal(4, results.Count);
            Assert.NotEmpty(formatted);
            Assert.Contains("Nearest Neighbor", formatted);
            Assert.Contains("2-Opt", formatted);
            Assert.Contains("Simulated Annealing", formatted);
            Assert.Contains("Genetic Algorithm", formatted);
        }

        [Fact]
        public async Task Integration_DataGenerator_AllPatterns_WithAllSolvers_ShouldWork()
        {
            // Arrange
            var generator = new TspDataGenerator(seed: 777);

            var testCases = new[]
            {
                ("Random", generator.GenerateRandomCities(5)),
                ("Circular", generator.GenerateCircularCities(5)),
                ("Grid", generator.GenerateGridCities(2, 3).Take(5).ToList())
            };

            var solver = new NearestNeighborSolver();

            // Act & Assert
            foreach (var (pattern, cities) in testCases)
            {
                var tour = await solver.SolveAsync(cities);

                Assert.NotNull(tour);
                Assert.Equal(cities.Count, tour.Cities.Count);
                Assert.True(tour.TotalDistance >= 0);
            }
        }

        [Theory]
        [InlineData(2)]
        [InlineData(5)]
        [InlineData(10)]
        public async Task Integration_ScaledGeneticAlgorithm_DifferentCityCounts_ShouldScale(int cityCount)
        {
            // Arrange
            var generator = new TspDataGenerator(seed: 888);
            var cities = generator.GenerateRandomCities(cityCount);
            var solver = GeneticAlgorithmSolver.CreateScaledGeneticSolver(cityCount);

            // Act
            var tour = await solver.SolveAsync(cities);

            // Assert
            Assert.NotNull(tour);
            Assert.Equal(cityCount, tour.Cities.Count);
            Assert.True(tour.TotalDistance > 0);
        }

        [Fact]
        public async Task Integration_ProgressEvents_AllSolvers_ShouldRaiseEvents()
        {
            // Arrange
            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 0),
                new City(2, "C", 1, 1),
                new City(3, "D", 0, 1)
            };

            var solvers = new List<ITspSolver>
            {
                new NearestNeighborSolver(),
                new TwoOptSolver(maxIterations: 5),
                new SimulatedAnnealingSolver(50, 0.8, 3),
                new GeneticAlgorithmSolver(5, 3, 0.1, 0.2)
            };

            // Act & Assert
            foreach (var solver in solvers)
            {
                var progressEvents = new List<TspProgressEventArgs>();
                solver.ProgressChanged += (s, e) => progressEvents.Add(e);

                var tour = await solver.SolveAsync(cities);

                Assert.NotNull(tour);
                // Most solvers should raise at least one progress event
                // (Some very fast solvers might not, depending on implementation)
            }
        }
    }

    // ============================================================================
    // PERFORMANCE AND STRESS TESTS
    // ============================================================================
    public class PerformanceTests
    {
        [Fact]
        public async Task Performance_NearestNeighbor_100Cities_ShouldCompleteQuickly()
        {
            // Arrange
            var generator = new TspDataGenerator(seed: 42);
            var cities = generator.GenerateRandomCities(100);
            var solver = new NearestNeighborSolver();

            // Act
            var startTime = DateTime.UtcNow;
            var tour = await solver.SolveAsync(cities);
            var elapsed = DateTime.UtcNow - startTime;

            // Assert
            Assert.NotNull(tour);
            Assert.Equal(100, tour.Cities.Count);
            Assert.True(tour.TotalDistance > 0);
            Assert.True(elapsed.TotalSeconds < 5); // Should be very fast
        }

        [Fact]
        public async Task Performance_AllSolvers_SmallProblem_ShouldComplete()
        {
            // Arrange
            var generator = new TspDataGenerator(seed: 555);
            var cities = generator.GenerateRandomCities(6);

            var solvers = new List<ITspSolver>
            {
                new NearestNeighborSolver(),
                new TwoOptSolver(maxIterations: 20),
                new SimulatedAnnealingSolver(100, 0.9, 10),
                new GeneticAlgorithmSolver(20, 10, 0.1, 0.2)
            };

            // Act
            var tasks = solvers.Select(solver => Task.Run(async () =>
            {
                var startTime = DateTime.UtcNow;
                var tour = await solver.SolveAsync(cities);
                var elapsed = DateTime.UtcNow - startTime;
                return new { Solver = solver.Name, Tour = tour, Elapsed = elapsed };
            })).ToList();

            var results = await Task.WhenAll(tasks);

            // Assert
            Assert.All(results, result =>
            {
                Assert.NotNull(result.Tour);
                Assert.Equal(6, result.Tour.Cities.Count);
                Assert.True(result.Tour.TotalDistance > 0);
                Assert.True(result.Elapsed.TotalSeconds < 30); // Reasonable time limit
            });
        }

        [Fact]
        public void Performance_DistanceMatrix_LargeProblem_ShouldBuildEfficiently()
        {
            // Arrange
            var generator = new TspDataGenerator(seed: 123);
            var cities = generator.GenerateRandomCities(500);
            var solver = new NearestNeighborSolver();

            // Act
            var startTime = DateTime.UtcNow;
            var matrix = typeof(TspSolverBase)
                .GetMethod("BuildDistanceMatrix", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)
                ?.Invoke(solver, new object[] { cities }) as double[,];
            var elapsed = DateTime.UtcNow - startTime;

            // Assert
            Assert.NotNull(matrix);
            Assert.Equal(500, matrix.GetLength(0));
            Assert.Equal(500, matrix.GetLength(1));
            Assert.True(elapsed.TotalSeconds < 2); // Should build quickly
        }

        [Fact]
        public async Task Performance_TourOperations_ShouldBeEfficient()
        {
            // Arrange
            var generator = new TspDataGenerator(seed: 456);
            var cities = generator.GenerateRandomCities(1000);
            var distanceMatrix = new double[1000, 1000];

            // Build distance matrix
            for (int i = 0; i < 1000; i++)
            {
                for (int j = 0; j < 1000; j++)
                {
                    distanceMatrix[i, j] = cities[i].DistanceTo(cities[j]);
                }
            }

            var tour = new Tour(cities, distanceMatrix);

            // Act & Assert - Multiple operations should be efficient
            var startTime = DateTime.UtcNow;

            // Test distance calculation caching
            var distance1 = tour.TotalDistance;
            var distance2 = tour.TotalDistance; // Should use cache
            Assert.Equal(distance1, distance2);

            // Test swapping
            tour.SwapCities(100, 200);
            var newDistance = tour.TotalDistance;

            // Test reversing
            tour.Reverse(50, 150);

            // Test cloning
            var cloned = tour.Clone();

            var elapsed = DateTime.UtcNow - startTime;

            Assert.True(elapsed.TotalSeconds < 1); // Operations should be fast
            Assert.NotEqual(distance1, newDistance); // Distance should change after modifications
            Assert.Equal(tour.TotalDistance, cloned.TotalDistance); // Clone should match
        }
    }

    // ============================================================================
    // EDGE CASE AND ERROR HANDLING TESTS
    // ============================================================================
    public class EdgeCaseTests
    {
        [Fact]
        public async Task EdgeCase_EmptyCityList_AllSolvers_ShouldHandle()
        {
            // Arrange
            var emptyCities = new List<City>();
            var solvers = TspSolverFactory.CreateAllSolvers().ToList();

            // Act & Assert
            foreach (var solver in solvers)
            {
                var tour = await solver.SolveAsync(emptyCities);
                Assert.NotNull(tour);
                Assert.Empty(tour.Cities);
                Assert.Equal(0.0, tour.TotalDistance);
            }
        }

        [Fact]
        public async Task EdgeCase_SingleCity_AllSolvers_ShouldHandle()
        {
            // Arrange
            var singleCity = new List<City> { new City(0, "Only", 5, 10) };
            var solvers = TspSolverFactory.CreateAllSolvers().ToList();

            // Act & Assert
            foreach (var solver in solvers)
            {
                var tour = await solver.SolveAsync(singleCity);
                Assert.NotNull(tour);
                Assert.Single(tour.Cities);
                Assert.Equal(0.0, tour.TotalDistance);
                Assert.Equal("Only", tour.Cities[0].Name);
            }
        }

        [Fact]
        public void EdgeCase_City_ExtremeCoordinates_ShouldWork()
        {
            // Arrange & Act
            var city1 = new City(0, "Extreme1", double.MaxValue / 2, double.MaxValue / 2);
            var city2 = new City(1, "Extreme2", double.MinValue / 2, double.MinValue / 2);

            // Assert
            Assert.True(double.IsFinite(city1.X));
            Assert.True(double.IsFinite(city1.Y));
            Assert.True(double.IsFinite(city2.X));
            Assert.True(double.IsFinite(city2.Y));

            var distance = city1.DistanceTo(city2);
            Assert.True(double.IsFinite(distance));
            Assert.True(distance > 0);
        }

        [Fact]
        public void EdgeCase_Tour_OutOfBoundsSwap_ShouldThrow()
        {
            // Arrange
            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 1)
            };
            var matrix = new double[2, 2];
            var tour = new Tour(cities, matrix);

            // Act & Assert
            Assert.Throws<ArgumentOutOfRangeException>(() => tour.SwapCities(-1, 0));
            Assert.Throws<ArgumentOutOfRangeException>(() => tour.SwapCities(0, 10));
        }

        [Fact]
        public void EdgeCase_Tour_InvalidReverseRange_ShouldHandle()
        {
            // Arrange
            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 1),
                new City(2, "C", 2, 2)
            };
            var matrix = new double[3, 3];
            var tour = new Tour(cities, matrix);
            var originalCities = tour.Cities.ToList();

            // Act - Reverse with start > end should not crash
            tour.Reverse(2, 1); // Invalid range

            // Assert - Tour should remain unchanged
            for (int i = 0; i < originalCities.Count; i++)
            {
                Assert.Equal(originalCities[i], tour.Cities[i]);
            }
        }

        [Fact]
        public void EdgeCase_DataGenerator_ZeroCities_ShouldReturnEmpty()
        {
            // Arrange
            var generator = new TspDataGenerator();

            // Act
            var randomCities = generator.GenerateRandomCities(0);
            var circularCities = generator.GenerateCircularCities(0);
            var gridCities = generator.GenerateGridCities(0, 0);

            // Assert
            Assert.Empty(randomCities);
            Assert.Empty(circularCities);
            Assert.Empty(gridCities);
        }

        [Fact]
        public void EdgeCase_DataGenerator_NegativeParameters_ShouldThrow()
        {
            // Arrange
            var generator = new TspDataGenerator();

            // Act & Assert
            Assert.Throws<ArgumentOutOfRangeException>(() => generator.GenerateRandomCities(-1));
            Assert.Throws<ArgumentOutOfRangeException>(() => generator.GenerateCircularCities(-1));
            Assert.Throws<ArgumentOutOfRangeException>(() => generator.GenerateGridCities(-1, 1));
            Assert.Throws<ArgumentOutOfRangeException>(() => generator.GenerateGridCities(1, -1));
        }

        [Fact]
        public void EdgeCase_GeneticAlgorithm_ZeroPopulation_ShouldThrow()
        {
            // Act & Assert
            Assert.Throws<ArgumentOutOfRangeException>(() =>
                new GeneticAlgorithmSolver(populationSize: 0));
        }

        [Fact]
        public void EdgeCase_GeneticAlgorithm_NegativeGenerations_ShouldThrow()
        {
            // Act & Assert
            Assert.Throws<ArgumentOutOfRangeException>(() =>
                new GeneticAlgorithmSolver(generations: -1));
        }

        [Theory]
        [InlineData(-0.1)] // Negative
        [InlineData(1.1)]  // Greater than 1
        public void EdgeCase_GeneticAlgorithm_InvalidRates_ShouldThrow(double invalidRate)
        {
            // Act & Assert
            Assert.Throws<ArgumentOutOfRangeException>(() =>
                new GeneticAlgorithmSolver(mutationRate: invalidRate));

            Assert.Throws<ArgumentOutOfRangeException>(() =>
                new GeneticAlgorithmSolver(elitismRate: invalidRate));
        }

        [Fact]
        public void EdgeCase_SimulatedAnnealing_InvalidParameters_ShouldThrow()
        {
            // Act & Assert
            Assert.Throws<ArgumentOutOfRangeException>(() =>
                new SimulatedAnnealingSolver(initialTemperature: -1));

            Assert.Throws<ArgumentOutOfRangeException>(() =>
                new SimulatedAnnealingSolver(coolingRate: 0)); // Should be > 0 and < 1

            Assert.Throws<ArgumentOutOfRangeException>(() =>
                new SimulatedAnnealingSolver(coolingRate: 1.1));

            Assert.Throws<ArgumentOutOfRangeException>(() =>
                new SimulatedAnnealingSolver(iterationsPerTemperature: 0));
        }

        [Fact]
        public void EdgeCase_TwoOpt_ZeroMaxIterations_ShouldThrow()
        {
            // Act & Assert
            Assert.Throws<ArgumentOutOfRangeException>(() =>
                new TwoOptSolver(maxIterations: 0));
        }

        [Fact]
        public async Task EdgeCase_CancellationToken_AlreadyCancelled_ShouldThrowImmediately()
        {
            // Arrange
            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 0)
            };

            var solvers = TspSolverFactory.CreateAllSolvers().ToList();
            using var cts = new CancellationTokenSource();
            cts.Cancel(); // Cancel before starting

            // Act & Assert
            foreach (var solver in solvers)
            {
                await Assert.ThrowsAsync<OperationCanceledException>(
                    () => solver.SolveAsync(cities, cts.Token));
            }
        }

        [Fact]
        public void EdgeCase_City_NaNCoordinates_ShouldThrow()
        {
            // Act & Assert
            Assert.Throws<ArgumentException>(() => new City(0, "NaN", double.NaN, 0));
            Assert.Throws<ArgumentException>(() => new City(0, "NaN", 0, double.NaN));
            Assert.Throws<ArgumentException>(() => new City(0, "Inf", double.PositiveInfinity, 0));
            Assert.Throws<ArgumentException>(() => new City(0, "Inf", 0, double.NegativeInfinity));
        }

        [Fact]
        public void EdgeCase_City_NullName_ShouldThrow()
        {
            // Act & Assert
            Assert.Throws<ArgumentNullException>(() => new City(0, null!, 0, 0));
            Assert.Throws<ArgumentException>(() => new City(0, "", 0, 0));
            Assert.Throws<ArgumentException>(() => new City(0, "   ", 0, 0));
        }

        [Fact]
        public void EdgeCase_Tour_NullCities_ShouldThrow()
        {
            // Act & Assert
            Assert.Throws<ArgumentNullException>(() =>
                new Tour(null!, new double[0, 0]));
        }

        [Fact]
        public void EdgeCase_Tour_NullDistanceMatrix_ShouldThrow()
        {
            // Act & Assert
            Assert.Throws<ArgumentNullException>(() =>
                new Tour(new List<City>(), null!));
        }
    }

    // ============================================================================
    // CONCURRENCY AND THREAD SAFETY TESTS
    // ============================================================================
    public class ConcurrencyTests
    {
        [Fact]
        public async Task Concurrency_MultipleSolvers_ParallelExecution_ShouldWork()
        {
            // Arrange
            var generator = new TspDataGenerator(seed: 999);
            var cities = generator.GenerateRandomCities(8);

            var tasks = new List<Task<Tour>>();
            for (int i = 0; i < 10; i++)
            {
                var solver = new NearestNeighborSolver();
                tasks.Add(Task.Run(() => solver.SolveAsync(cities)));
            }

            // Act
            var tours = await Task.WhenAll(tasks);

            // Assert
            Assert.Equal(10, tours.Length);
            Assert.All(tours, tour =>
            {
                Assert.NotNull(tour);
                Assert.Equal(8, tour.Cities.Count);
            });

            // All should have the same result (deterministic)
            var firstDistance = tours[0].TotalDistance;
            Assert.All(tours, tour => Assert.Equal(firstDistance, tour.TotalDistance));
        }

        [Fact]
        public async Task Concurrency_SameSolver_MultipleCallsSequentially_ShouldWork()
        {
            // Arrange
            var solver = new NearestNeighborSolver();
            var generator = new TspDataGenerator(seed: 111);

            // Act
            var tasks = new List<Task<Tour>>();
            for (int i = 0; i < 5; i++)
            {
                var cities = generator.GenerateRandomCities(6);
                tasks.Add(solver.SolveAsync(cities));
            }

            var tours = await Task.WhenAll(tasks);

            // Assert
            Assert.Equal(5, tours.Length);
            Assert.All(tours, tour =>
            {
                Assert.NotNull(tour);
                Assert.Equal(6, tour.Cities.Count);
            });
        }

        [Fact]
        public void Concurrency_TourOperations_ShouldBeThreadSafe()
        {
            // Arrange
            var cities = new List<City>();
            for (int i = 0; i < 100; i++)
            {
                cities.Add(new City(i, $"City{i}", i, i * 2));
            }

            var distanceMatrix = new double[100, 100];
            for (int i = 0; i < 100; i++)
            {
                for (int j = 0; j < 100; j++)
                {
                    distanceMatrix[i, j] = cities[i].DistanceTo(cities[j]);
                }
            }

            var tour = new Tour(cities, distanceMatrix);

            // Act - Multiple threads reading distance (cached value)
            var tasks = new List<Task<double>>();
            for (int i = 0; i < 20; i++)
            {
                tasks.Add(Task.Run(() => tour.TotalDistance));
            }

            var distances = Task.WhenAll(tasks).Result;

            // Assert
            Assert.All(distances, distance => Assert.Equal(distances[0], distance));
        }
    }

    // ============================================================================
    // LOGGING AND OBSERVABILITY TESTS
    // ============================================================================
    public class LoggingTests
    {
        private class TestLogger : ILogger
        {
            public List<string> LogMessages { get; } = new();

            public IDisposable BeginScope<TState>(TState state) =>
                throw new NotImplementedException();

            public bool IsEnabled(LogLevel logLevel) => true;

            public void Log<TState>(LogLevel logLevel, EventId eventId, TState state,
                Exception? exception, Func<TState, Exception?, string> formatter)
            {
                LogMessages.Add(formatter(state, exception));
            }
        }

        private class TestLoggerProvider : ILoggerProvider
        {
            public TestLogger TestLogger { get; } = new();

            public ILogger CreateLogger(string categoryName) => TestLogger;
            public void Dispose() { }
        }

        [Fact]
        public async Task Logging_NearestNeighborSolver_ShouldLogProgress()
        {
            // Arrange
            var loggerProvider = new TestLoggerProvider();
            using var loggerFactory = LoggerFactory.Create(builder =>
                builder.AddProvider(loggerProvider).SetMinimumLevel(LogLevel.Debug));

            var solver = new NearestNeighborSolver(loggerFactory.CreateLogger<NearestNeighborSolver>());
            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 0),
                new City(2, "C", 2, 0)
            };

            // Act
            await solver.SolveAsync(cities);

            // Assert
            Assert.True(loggerProvider.TestLogger.LogMessages.Count > 0);
            Assert.Contains(loggerProvider.TestLogger.LogMessages,
                msg => msg.Contains("Starting Nearest Neighbor"));
        }

        [Fact]
        public async Task Logging_TspBenchmark_ShouldLogResults()
        {
            // Arrange
            var loggerProvider = new TestLoggerProvider();
            using var loggerFactory = LoggerFactory.Create(builder =>
                builder.AddProvider(loggerProvider).SetMinimumLevel(LogLevel.Information));

            var benchmark = new TspBenchmark(loggerFactory.CreateLogger<TspBenchmark>());
            var cities = new List<City>
            {
                new City(0, "A", 0, 0),
                new City(1, "B", 1, 0)
            };

            var solvers = new List<ITspSolver>
            {
                new NearestNeighborSolver()
            };

            // Act
            await benchmark.RunBenchmarkAsync(cities, solvers);

            // Assert
            Assert.True(loggerProvider.TestLogger.LogMessages.Count > 0);
            Assert.Contains(loggerProvider.TestLogger.LogMessages,
                msg => msg.Contains("Starting benchmark"));
        }

        [Fact]
        public void Logging_TspDataGenerator_ShouldLogGeneration()
        {
            // Arrange
            var loggerProvider = new TestLoggerProvider();
            using var loggerFactory = LoggerFactory.Create(builder =>
                builder.AddProvider(loggerProvider).SetMinimumLevel(LogLevel.Information));

            var generator = new TspDataGenerator(seed: 123,
                loggerFactory.CreateLogger<TspDataGenerator>());

            // Act
            generator.GenerateRandomCities(5);

            // Assert
            Assert.Contains(loggerProvider.TestLogger.LogMessages,
                msg => msg.Contains("Generated") && msg.Contains("random cities"));
        }
    }

    // ============================================================================
    // HELPER METHODS AND UTILITIES
    // ============================================================================
    internal static class TestHelpers
    {
        public static List<City> CreateTestCities(int count, int seed = 42)
        {
            var generator = new TspDataGenerator(seed);
            return generator.GenerateRandomCities(count).ToList();
        }

        public static double[,] CreateDistanceMatrix(IReadOnlyList<City> cities)
        {
            var n = cities.Count;
            var matrix = new double[n, n];
            for (int i = 0; i < n; i++)
            {
                for (int j = 0; j < n; j++)
                {
                    matrix[i, j] = cities[i].DistanceTo(cities[j]);
                }
            }
            return matrix;
        }

        public static bool AreToursEquivalent(Tour tour1, Tour tour2, double tolerance = 0.01)
        {
            if (tour1.Cities.Count != tour2.Cities.Count)
                return false;

            return Math.Abs(tour1.TotalDistance - tour2.TotalDistance) < tolerance;
        }

        public static void AssertTourIsValid(Tour tour, IReadOnlyList<City> originalCities)
        {
            Assert.NotNull(tour);
            Assert.Equal(originalCities.Count, tour.Cities.Count);
            Assert.True(tour.TotalDistance >= 0);

            // All original cities should be present
            var originalIds = originalCities.Select(c => c.Id).OrderBy(id => id).ToList();
            var tourIds = tour.Cities.Select(c => c.Id).OrderBy(id => id).ToList();
            Assert.Equal(originalIds, tourIds);
        }

        public static async Task<TimeSpan> MeasureExecutionTime(Func<Task> action)
        {
            var startTime = DateTime.UtcNow;
            await action();
            return DateTime.UtcNow - startTime;
        }
    }
}
PS C:\code\TSP> dotnet test TSP.sln --configuration Release --no-build --verbosity normal

Build succeeded in 0.9s
PS C:\code\TSP> dotnet test TSP.sln --configuration Release --no-build --verbosity normal

Build succeeded in 0.9s
PS C:\code\TSP>
