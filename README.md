# TSP Solver

[![Build Status](https://github.com/kusl/tsp/actions/workflows/build.yml/badge.svg)](https://github.com/kusl/tsp/actions/workflows/build.yml)
[![Release](https://github.com/kusl/tsp/actions/workflows/release.yml/badge.svg)](https://github.com/kusl/tsp/actions/workflows/release.yml)

## ðŸš€ Quick Start

### Download Pre-built Binaries
Download the latest release for your platform from [Releases](https://github.com/kusl/tsp/releases/latest)

### Run with Docker
```bash
docker run --rm -it ghcr.io/kusl/tsp:latest
```

### Build from Source
```bash
dotnet build TSP.sln
dotnet run --project TravelingSalesman.ConsoleApp
```

## ðŸ”„ Version Upgrade
When upgrading to a new .NET version, only update 3 lines in `Directory.Build.props`:
- `<TargetFramework>net10.0</TargetFramework>`
- `<DotNetVersion>10.0</DotNetVersion>`
- `<DotNetChannel>10.0</DotNetChannel>`
```

### 4. **Consider Simplifying Release Strategy**:
Instead of a release per commit, consider:
- **Rolling release**: Single "latest" tag that updates
- **Nightly builds**: Once per day
- **Tagged releases**: Only on version tags

## ðŸŽ¯ Summary:

Your implementation successfully addresses both concerns:
1. âœ… **Binary releases**: AOT compilation creates standalone executables
2. âœ… **Version management**: Centralized in `Directory.Build.props` and Dockerfile ARGs

The architecture is clean, maintainable, and ready for future .NET versions. Just fix the YAML formatting, push your changes, and you'll have a fully automated CI/CD pipeline with binary releases!

LLM Notice: This project contains code generated by Large Language Models such as Claude and Gemini. All code is experimental whether explicitly stated or not.