<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Traveling Salesman Problem Solver - C# Implementation</title>
    <style>
        :root {
            --primary-color: #2563eb;
            --secondary-color: #1e40af;
            --accent-color: #10b981;
            --bg-color: #f9fafb;
            --text-color: #1f2937;
            --code-bg: #1f2937;
            --border-color: #e5e7eb;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .content-wrapper {
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            color: white;
            padding: 60px 40px;
            text-align: center;
        }

        h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
        }

        .subtitle {
            font-size: 1.2em;
            opacity: 0.95;
            margin-bottom: 20px;
        }

        .links {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .links a {
            display: inline-block;
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            text-decoration: none;
            border-radius: 6px;
            transition: all 0.3s;
            backdrop-filter: blur(10px);
        }

        .links a:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .warning-banner {
            background: linear-gradient(135deg, #fbbf24, #f59e0b);
            padding: 15px 40px;
            text-align: center;
            color: #7c2d12;
            font-weight: 500;
        }

        .warning-banner .icon {
            display: inline-block;
            margin-right: 10px;
            font-size: 1.2em;
        }

        main {
            padding: 40px;
        }

        section {
            margin-bottom: 50px;
        }

        h2 {
            color: var(--primary-color);
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid var(--primary-color);
        }

        h3 {
            color: var(--secondary-color);
            font-size: 1.5em;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        h4 {
            color: var(--text-color);
            font-size: 1.2em;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        p {
            margin-bottom: 15px;
            text-align: justify;
        }

        .highlight-box {
            background: linear-gradient(135deg, #f0f9ff, #e0f2fe);
            border-left: 4px solid var(--primary-color);
            padding: 20px;
            margin: 20px 0;
            border-radius: 6px;
        }

        .complexity-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .complexity-table th,
        .complexity-table td {
            padding: 12px;
            text-align: left;
            border: 1px solid var(--border-color);
        }

        .complexity-table th {
            background: var(--primary-color);
            color: white;
            font-weight: 600;
        }

        .complexity-table tr:nth-child(even) {
            background: var(--bg-color);
        }

        .algorithm-card {
            background: white;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            transition: all 0.3s;
        }

        .algorithm-card:hover {
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
            transform: translateY(-2px);
        }

        .algorithm-card h4 {
            color: var(--accent-color);
        }

        code {
            background: #f3f4f6;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            color: #dc2626;
        }

        .code-block {
            background: var(--code-bg);
            color: #f3f4f6;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            line-height: 1.5;
        }

        .features-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .feature-card {
            background: linear-gradient(135deg, #fef3c7, #fde68a);
            padding: 20px;
            border-radius: 8px;
            border: 2px solid #f59e0b;
        }

        .feature-card h4 {
            color: #92400e;
            margin-bottom: 10px;
        }

        ul, ol {
            margin-left: 30px;
            margin-bottom: 15px;
        }

        li {
            margin-bottom: 8px;
        }

        .tech-stack {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 20px 0;
        }

        .tech-badge {
            background: var(--primary-color);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 500;
        }

        footer {
            background: var(--code-bg);
            color: white;
            text-align: center;
            padding: 30px 40px;
        }

        footer a {
            color: #60a5fa;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2em;
            }

            h2 {
                font-size: 1.5em;
            }

            main {
                padding: 20px;
            }

            .complexity-table {
                font-size: 0.9em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="content-wrapper">
            <header>
                <h1>🗺️ Traveling Salesman Problem Solver</h1>
                <p class="subtitle">A High-Performance C# Implementation with Multiple Algorithms</p>
                <div class="links">
                    <a href="https://github.com/kusl/tsp">📦 GitHub Repository</a>
                    <a href="https://kusl.github.io/tsp/build.txt">🔧 Build/test Log</a>
                    <a href="https://kusl.github.io/tsp/results.html">📊 Benchmark Results</a>
                    <a href="https://github.com/kusl/tsp/blob/master/README.md">README</a>
                </div>
            </header>

            <div class="warning-banner">
                <span class="icon">⚠️</span>
                <strong>Note:</strong> This documentation was generated with assistance from a Large Language Model (LLM) and may contain inaccuracies. Please verify technical details independently.
            </div>

            <main>
                <section id="introduction">
                    <h2>Understanding the Traveling Salesman Problem</h2>
                    
                    <p>
                        The <strong>Traveling Salesman Problem (TSP)</strong> is one of the most famous and intensively studied problems in computational mathematics and computer science. At its core, the problem asks a deceptively simple question: "Given a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city exactly once and returns to the origin city?"
                    </p>

                    <p>
                        While this question might seem straightforward, the TSP has profound implications that extend far beyond route planning. It serves as a benchmark problem for optimization algorithms and has become a cornerstone in the study of computational complexity theory.
                    </p>

                    <div class="highlight-box">
                        <h4>🎯 Formal Definition</h4>
                        <p>
                            Given a complete weighted graph G = (V, E) where V is a set of n vertices (cities) and E is a set of edges with weights w(i,j) representing distances, find a Hamiltonian cycle (a cycle that visits each vertex exactly once) with minimum total weight.
                        </p>
                    </div>
                </section>

                <section id="importance">
                    <h2>Why TSP Matters</h2>
                    
                    <h3>Real-World Applications</h3>
                    <p>
                        The TSP is not just an academic exercise. Its applications permeate numerous industries and fields:
                    </p>

                    <div class="features-grid">
                        <div class="feature-card">
                            <h4>📦 Logistics & Delivery</h4>
                            <p>Optimizing delivery routes for packages, food delivery, and postal services to minimize fuel consumption and time.</p>
                        </div>
                        <div class="feature-card">
                            <h4>🏭 Manufacturing</h4>
                            <p>Minimizing tool movement in CNC machines, optimizing drilling sequences in PCB manufacturing, and robot path planning.</p>
                        </div>
                        <div class="feature-card">
                            <h4>🧬 Bioinformatics</h4>
                            <p>DNA sequencing, protein folding analysis, and genome mapping where finding optimal sequences is crucial.</p>
                        </div>
                        <div class="feature-card">
                            <h4>🖥️ Computer Architecture</h4>
                            <p>VLSI chip design, circuit board layout optimization, and network topology design.</p>
                        </div>
                        <div class="feature-card">
                            <h4>🔬 Scientific Research</h4>
                            <p>Telescope scheduling for astronomy, X-ray crystallography beam path optimization.</p>
                        </div>
                        <div class="feature-card">
                            <h4>🎮 Entertainment</h4>
                            <p>Video game AI pathfinding, animation keyframe optimization, and procedural content generation.</p>
                        </div>
                    </div>

                    <h3>Theoretical Significance</h3>
                    <p>
                        Beyond practical applications, the TSP holds immense theoretical importance. It serves as a canonical example of an NP-hard problem, making it a crucial subject in the study of computational complexity. Understanding TSP helps computer scientists develop better approximation algorithms and heuristics for a whole class of difficult optimization problems.
                    </p>
                </section>

                <section id="complexity">
                    <h2>Computational Complexity: P vs NP</h2>
                    
                    <h3>Understanding Complexity Classes</h3>
                    <p>
                        To truly appreciate why the TSP is so challenging, we need to understand computational complexity theory, particularly the concepts of P and NP complexity classes.
                    </p>

                    <h4>The Class P (Polynomial Time)</h4>
                    <p>
                        <strong>P</strong> is the class of decision problems that can be solved by a deterministic Turing machine in polynomial time. In practical terms, these are problems where we can find a solution efficiently, with the computation time growing polynomially (like n², n³, or even n¹⁰⁰) with the input size n.
                    </p>

                    <p>
                        Examples of problems in P include:
                    </p>
                    <ul>
                        <li><strong>Sorting:</strong> Can be solved in O(n log n) time</li>
                        <li><strong>Shortest path in a graph:</strong> Dijkstra's algorithm runs in O(V² log V) time</li>
                        <li><strong>Maximum flow:</strong> Can be solved in polynomial time using various algorithms</li>
                        <li><strong>Linear programming:</strong> Despite seeming complex, can be solved in polynomial time</li>
                    </ul>

                    <h4>The Class NP (Nondeterministic Polynomial Time)</h4>
                    <p>
                        <strong>NP</strong> is the class of decision problems for which a given solution can be verified in polynomial time. The name comes from "Nondeterministic Polynomial time" because these problems could theoretically be solved in polynomial time by a nondeterministic Turing machine (a theoretical computer that can explore many computational paths simultaneously).
                    </p>

                    <p>
                        Key insight: Every problem in P is also in NP (if we can solve it quickly, we can certainly verify a solution quickly), but it's unknown whether every problem in NP is also in P. This is the famous <strong>P vs NP problem</strong>, one of the seven Millennium Prize Problems with a $1 million reward for its solution.
                    </p>

                    <div class="highlight-box">
                        <h4>🧮 The Million Dollar Question</h4>
                        <p>
                            Does P = NP? In other words, if we can quickly verify a solution to a problem, can we also quickly find that solution? Most computer scientists believe P ≠ NP, but no one has been able to prove it conclusively.
                        </p>
                    </div>

                    <h4>NP-Complete and NP-Hard</h4>
                    <p>
                        <strong>NP-Complete</strong> problems are the hardest problems in NP. They have two properties:
                    </p>
                    <ol>
                        <li>They are in NP (solutions can be verified in polynomial time)</li>
                        <li>Every other problem in NP can be reduced to them in polynomial time</li>
                    </ol>

                    <p>
                        <strong>NP-Hard</strong> problems are at least as hard as NP-Complete problems, but they don't have to be in NP themselves. The optimization version of TSP (finding the shortest tour) is NP-Hard, while the decision version (is there a tour shorter than k?) is NP-Complete.
                    </p>

                    <h3>TSP's Complexity</h3>
                    <p>
                        The TSP's difficulty becomes apparent when we consider the number of possible tours. For n cities, there are (n-1)!/2 possible tours (we divide by 2 because traveling a tour forward or backward gives the same distance). This factorial growth is devastating:
                    </p>

                    <table class="complexity-table">
                        <thead>
                            <tr>
                                <th>Number of Cities</th>
                                <th>Possible Tours</th>
                                <th>Time to Check All (1 tour/nanosecond)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>5</td>
                                <td>12</td>
                                <td>12 nanoseconds</td>
                            </tr>
                            <tr>
                                <td>10</td>
                                <td>181,440</td>
                                <td>0.18 milliseconds</td>
                            </tr>
                            <tr>
                                <td>15</td>
                                <td>43,589,145,600</td>
                                <td>43.6 seconds</td>
                            </tr>
                            <tr>
                                <td>20</td>
                                <td>60,822,550,204,416,000</td>
                                <td>1.93 years</td>
                            </tr>
                            <tr>
                                <td>25</td>
                                <td>310,224,200,866,619,719,680,000</td>
                                <td>9.8 million years</td>
                            </tr>
                            <tr>
                                <td>50</td>
                                <td>~3.04 × 10⁶²</td>
                                <td>Longer than the age of the universe</td>
                            </tr>
                        </tbody>
                    </table>

                    <p>
                        This exponential explosion in possibilities is why we can't simply check all possible tours for anything but the smallest problems. Instead, we must use clever algorithms that find good (though not necessarily optimal) solutions in reasonable time.
                    </p>
                </section>

                <section id="algorithms">
                    <h2>Solution Approaches</h2>
                    
                    <p>
                        Since finding the optimal solution is computationally infeasible for large instances, various approaches have been developed to tackle the TSP:
                    </p>

                    <h3>Exact Algorithms</h3>
                    <p>
                        These guarantee finding the optimal solution but have exponential worst-case time complexity:
                    </p>
                    <ul>
                        <li><strong>Brute Force:</strong> Check all possible tours - O((n-1)!/2)</li>
                        <li><strong>Dynamic Programming (Held-Karp):</strong> Reduces complexity to O(n²2ⁿ)</li>
                        <li><strong>Branch and Bound:</strong> Prunes the search space using bounds</li>
                        <li><strong>Integer Linear Programming:</strong> Formulates TSP as an ILP problem</li>
                    </ul>

                    <h3>Approximation Algorithms</h3>
                    <p>
                        These provide solutions with guaranteed quality bounds:
                    </p>
                    <ul>
                        <li><strong>Christofides Algorithm:</strong> Guarantees solution within 1.5× optimal for metric TSP</li>
                        <li><strong>MST-based algorithms:</strong> Use minimum spanning trees as a starting point</li>
                    </ul>

                    <h3>Heuristic and Metaheuristic Algorithms</h3>
                    <p>
                        These provide good solutions quickly without quality guarantees:
                    </p>

                    <div class="algorithm-card">
                        <h4>🎯 Nearest Neighbor</h4>
                        <p><strong>How it works:</strong> Start at a city and repeatedly visit the nearest unvisited city until all are visited.</p>
                        <p><strong>Time Complexity:</strong> O(n²)</p>
                        <p><strong>Pros:</strong> Very fast, simple to implement, deterministic</p>
                        <p><strong>Cons:</strong> Can produce solutions 25% worse than optimal on average</p>
                    </div>

                    <div class="algorithm-card">
                        <h4>🔄 2-Opt</h4>
                        <p><strong>How it works:</strong> Iteratively improve a tour by removing two edges and reconnecting the path in a different way.</p>
                        <p><strong>Time Complexity:</strong> O(n²) per improvement iteration</p>
                        <p><strong>Pros:</strong> Simple local search, often significantly improves initial solutions</p>
                        <p><strong>Cons:</strong> Can get stuck in local optima</p>
                    </div>

                    <div class="algorithm-card">
                        <h4>🌡️ Simulated Annealing</h4>
                        <p><strong>How it works:</strong> Inspired by metallurgy, it accepts worse solutions probabilistically to escape local optima, with probability decreasing over time.</p>
                        <p><strong>Time Complexity:</strong> O(n) per iteration × number of iterations</p>
                        <p><strong>Pros:</strong> Can escape local optima, tunable parameters</p>
                        <p><strong>Cons:</strong> Slower than simple heuristics, requires parameter tuning</p>
                    </div>

                    <div class="algorithm-card">
                        <h4>🧬 Genetic Algorithm</h4>
                        <p><strong>How it works:</strong> Evolves a population of solutions using selection, crossover, and mutation operations inspired by natural evolution.</p>
                        <p><strong>Time Complexity:</strong> O(population × generations × n)</p>
                        <p><strong>Pros:</strong> Good for large problems, naturally parallel, explores diverse solutions</p>
                        <p><strong>Cons:</strong> Slowest approach, many parameters to tune</p>
                    </div>
                </section>

                <section id="implementation">
                    <h2>Our C# Implementation</h2>
                    
                    <p>
                        This project provides a production-ready C# implementation of the TSP with multiple solving algorithms. Built with modern .NET features and optimized for performance, it serves as both an educational tool and a practical solver for real-world problems.
                    </p>

                    <h3>Key Features</h3>
                    <div class="features-grid">
                        <div class="feature-card">
                            <h4>⚡ High Performance</h4>
                            <p>Native AOT compilation, unsafe code optimizations, and efficient data structures</p>
                        </div>
                        <div class="feature-card">
                            <h4>🔧 Multiple Algorithms</h4>
                            <p>Four different solving strategies with configurable parameters</p>
                        </div>
                        <div class="feature-card">
                            <h4>📊 Benchmarking</h4>
                            <p>Built-in performance comparison tools and progress tracking</p>
                        </div>
                        <div class="feature-card">
                            <h4>📝 Comprehensive Logging</h4>
                            <p>Detailed logging with Serilog for debugging and analysis</p>
                        </div>
                        <div class="feature-card">
                            <h4>🧪 Well Tested</h4>
                            <p>Unit tests with xUnit and BDD tests with Reqnroll</p>
                        </div>
                        <div class="feature-card">
                            <h4>🐳 Docker Support</h4>
                            <p>Containerized deployment for easy distribution</p>
                        </div>
                    </div>

                    <h3>Technology Stack</h3>
                    <div class="tech-stack">
                        <span class="tech-badge">.NET 9</span>
                        <span class="tech-badge">C# 12</span>
                        <span class="tech-badge">Native AOT</span>
                        <span class="tech-badge">Serilog</span>
                        <span class="tech-badge">xUnit</span>
                        <span class="tech-badge">Reqnroll BDD</span>
                        <span class="tech-badge">Docker</span>
                        <span class="tech-badge">GitHub Actions</span>
                    </div>

                    <h3>Architecture Highlights</h3>
                    <ul>
                        <li><strong>Clean Architecture:</strong> Separation of concerns with Core library and Console application</li>
                        <li><strong>Strategy Pattern:</strong> Common interface for all solver algorithms</li>
                        <li><strong>Factory Pattern:</strong> Easy solver instantiation with logging support</li>
                        <li><strong>Async/Await:</strong> Modern asynchronous programming patterns</li>
                        <li><strong>Memory Efficiency:</strong> Caching, unsafe code blocks for performance-critical sections</li>
                        <li><strong>Cross-Platform:</strong> Runs on Windows, Linux, and macOS</li>
                    </ul>

                    <h3>Sample Usage</h3>
                    <div class="code-block">
// Generate test cities
var generator = new TspDataGenerator(seed: 42);
var cities = generator.GenerateRandomCities(20);

// Solve using different algorithms
var solvers = new List&lt;ITspSolver&gt;
{
    new NearestNeighborSolver(),
    new TwoOptSolver(maxIterations: 100),
    new SimulatedAnnealingSolver(initialTemperature: 1000),
    new GeneticAlgorithmSolver(populationSize: 50, generations: 100)
};

// Run benchmark
var benchmark = new TspBenchmark();
var results = await benchmark.RunBenchmarkAsync(cities, solvers);

// Display results
Console.WriteLine(benchmark.FormatResults(results));
                    </div>
                </section>

                <section id="getting-started">
                    <h2>Getting Started</h2>
                    
                    <h3>Quick Start with Docker</h3>
                    <div class="code-block">
# Pull and run the Docker image
docker run -it ghcr.io/kusl/tsp:latest

# Or build from source
git clone https://github.com/kusl/tsp.git
cd tsp
docker build -t tsp-solver .
docker run -it tsp-solver
                    </div>

                    <h3>Building from Source</h3>
                    <div class="code-block">
# Prerequisites: .NET 9 SDK

# Clone the repository
git clone https://github.com/kusl/tsp.git
cd tsp

# Build the solution
dotnet build

# Run tests
dotnet test

# Run the console application
dotnet run --project TravelingSalesman.ConsoleApp
                    </div>

                    <h3>Native AOT Compilation</h3>
                    <div class="code-block">
# Build native executable (no .NET runtime required)
dotnet publish TravelingSalesman.ConsoleApp -c Release -r linux-x64 --self-contained -p:PublishAot=true

# Run the native executable
./publish/TravelingSalesman.ConsoleApp
                    </div>

                    <p>
                        For detailed build instructions and platform-specific guidance, please refer to the <a href="https://kusl.github.io/tsp/build.txt">build instructions</a>.
                    </p>
                </section>

                <section id="results">
                    <h2>Performance Results</h2>
                    
                    <p>
                        We've conducted extensive benchmarks comparing all four algorithms on various problem sizes and city distributions. The results demonstrate the trade-offs between solution quality and computation time.
                    </p>

                    <div class="highlight-box">
                        <h4>📊 Key Findings</h4>
                        <ul>
                            <li><strong>Small problems (< 20 cities):</strong> All algorithms find near-optimal solutions quickly</li>
                            <li><strong>Medium problems (20-100 cities):</strong> 2-Opt provides best quality/speed trade-off</li>
                            <li><strong>Large problems (> 100 cities):</strong> Genetic Algorithm finds best solutions but requires more time</li>
                            <li><strong>Real-time requirements:</strong> Nearest Neighbor is unbeatable for speed</li>
                        </ul>
                    </div>

                    <p>
                        View our comprehensive <a href="https://kusl.github.io/tsp/results.html">benchmark results</a> for detailed performance comparisons, including:
                    </p>
                    <ul>
                        <li>Algorithm performance across different problem sizes</li>
                        <li>Solution quality comparisons</li>
                        <li>Execution time analysis</li>
                        <li>Memory usage profiling</li>
                        <li>Convergence characteristics</li>
                    </ul>
                </section>

                <section id="future-work">
                    <h2>Future Enhancements</h2>
                    
                    <p>
                        While our implementation is comprehensive, there are always opportunities for improvement:
                    </p>
                    
                    <ul>
                        <li><strong>Additional Algorithms:</strong> Ant Colony Optimization, Tabu Search, Lin-Kernighan heuristic</li>
                        <li><strong>Parallel Processing:</strong> GPU acceleration for genetic algorithms</li>
                        <li><strong>Machine Learning:</strong> Learning-based heuristics and reinforcement learning approaches</li>
                        <li><strong>Visualization:</strong> Interactive web-based visualization of tours and algorithm progress</li>
                        <li><strong>Constraint Support:</strong> Time windows, capacity constraints, multiple salesmen</li>
                        <li><strong>Real-world Data:</strong> Integration with mapping APIs for actual city distances</li>
                    </ul>
                </section>

                <section id="conclusion">
                    <h2>Conclusion</h2>
                    
                    <p>
                        The Traveling Salesman Problem continues to captivate researchers and practitioners alike, serving as a bridge between theoretical computer science and practical optimization. Through this implementation, we've demonstrated that while finding the absolute optimal solution remains computationally intractable for large instances, sophisticated heuristics can find excellent solutions in reasonable time.
                    </p>

                    <p>
                        Whether you're a student learning about computational complexity, a researcher exploring optimization algorithms, or a practitioner needing to solve routing problems, we hope this project provides both educational value and practical utility. The combination of multiple algorithms, comprehensive testing, and modern C# features makes this a robust foundation for TSP-related work.
                    </p>

                    <p>
                        As computing power continues to grow and new algorithmic insights emerge, the quest for better TSP solutions continues. Perhaps one day, someone will prove whether P equals NP, fundamentally changing our understanding of computational complexity. Until then, we continue to push the boundaries of what's practically solvable, one algorithm at a time.
                    </p>
                </section>
            </main>

            <footer>
                <p>© 2024 TSP Solver Project | <a href="https://github.com/kusl/tsp">GitHub</a> | <a href="https://github.com/kusl/tsp/blob/master/LICENSE.txt">MIT License</a></p>
                <p style="margin-top: 10px; font-size: 0.9em; opacity: 0.8;">
                    ⚠️ This documentation was generated with LLM assistance and may contain inaccuracies.
                </p>
            </footer>
        </div>
    </div>
</body>
</html>
